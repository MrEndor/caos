##### Что такое сигналы?

**Сигналы** -- это асинхронные уведомления, отправляемые процессу или конкретному
потоку в процессе для уведомления об имении события.

**Асинхронность** означает, что сигнал может быть получен в любой момент времени
выполнения процесса -- это непредсказуемо и не связано с текущим выполнением кода.

Когда процесс получает сигнал:

1. его текущее выполнение **приостанавливается**;
2. **вызывается обработчик сигнала** (если установлен), либо выполняется действие по умолчанию;
3. после обработчика выполнение **продолжается**.

Сигналы используются для:

- завершения процесса (`SIGTERM`, `SIGKILL`);
- приостановки/возобновления (`SIGSTOP`, `SIGCONT`);
- отладки (`SIGTRAP`);
- обработки ошибок (`SIGSEGV`, `SIGFPE`);
- синхронизации между процессами;
- уведомления о состоянии дочерних процессов (`SIGCHLD`).

##### Как послать сигнал процессу из терминала, а также из кода программы?

**Из терминала:**

```bash
kill -SIGTERM <pid>         # отправить SIGTERM (15)
kill -9 <pid>               # отправить SIGKILL (9)
kill -STOP <pid>            # отправить SIGSTOP (19)
kill -CONT <pid>            # отправить SIGCONT (18)

# Или через killall
killall -TERM prog_name
```

**Из кода:**

```c
#include <signal.h>
#include <unistd.h>

// Отправить сигнал другому процессу
kill(12345, SIGTERM);          // SIGTERM к процессу 12345
kill(12345, SIGUSR1);          // пользовательский сигнал 1

// Отправить сигнал целой группе процессов
kill(-12345, SIGTERM);         // минус -- это группа процессов

// Отправить сигнал всем процессам пользователя (требует прав)
kill(-1, SIGTERM);
```

##### Перечислите известные вам стандартные сигналы с объяснением, для чего они применяются.

| Номер | Имя     | Описание                                      | Действие по умолчанию | Может быть перехвачено? |
|-------|---------|-----------------------------------------------|-----------------------|-------------------------|
| 1     | SIGHUP  | Разрыв связи с терминалом                     | Завершить             | Да                      |
| 2     | SIGINT  | Interrupt (Ctrl+C)                            | Завершить             | Да                      |
| 3     | SIGQUIT | Quit (Ctrl+\\)                                | Завершить + core dump | Да                      |
| 4     | SIGILL  | Illegal instruction (неверная команда)        | Завершить + core dump | Да                      |
| 5     | SIGTRAP | Trap (точка останова для отладки)             | Завершить + core dump | Да                      |
| 6     | SIGABRT | Abort (вызвано abort())                       | Завершить + core dump | Да                      |
| 8     | SIGFPE  | Floating point exception (деление на 0)       | Завершить + core dump | Да                      |
| 9     | SIGKILL | Убить процесс (нельзя перехватить)            | Завершить             | **НЕТ**                 |
| 10    | SIGUSR1 | Пользовательский сигнал 1                     | Завершить             | Да                      |
| 11    | SIGSEGV | Segmentation fault (плохой адрес памяти)      | Завершить + core dump | Да                      |
| 12    | SIGUSR2 | Пользовательский сигнал 2                     | Завершить             | Да                      |
| 13    | SIGPIPE | Запись в закрытый pipe                        | Завершить             | Да                      |
| 15    | SIGTERM | Graceful termination (вежливое завершение)    | Завершить             | Да                      |
| 17    | SIGCHLD | Дочерний процесс завершился или остановился   | Игнорировать          | Да                      |
| 18    | SIGCONT | Продолжить выполнение остановленного процесса | Продолжить            | Да                      |
| 19    | SIGSTOP | Остановить процесс (нельзя перехватить)       | Остановить            | **НЕТ**                 |

##### Какова стандартная реакция процессов на каждый из сигналов?

По умолчанию:

- **SIGKILL, SIGSTOP** -- нельзя перехватить, игнорировать или заблокировать (ядро сразу выполняет действие, минуя
  обработчик);
- **SIGSEGV, SIGFPE, SIGILL, SIGTRAP, SIGABRT** -- завершают процесс с core dump;
- **SIGTERM, SIGINT, SIGHUP** -- завершают процесс;
- **SIGCONT** -- возобновляет остановленный процесс;
- **SIGUSR1, SIGUSR2** -- по умолчанию завершают (но часто перехватываются программой для своих целей);
- **SIGPIPE** -- по умолчанию завершает (возникает при попытке записи в закрытый pipe);
- **SIGCHLD** -- по умолчанию игнорируется (используется для мониторинга дочерних процессов);
- **SIGCONT** -- автоматически разблокирует процесс, даже если он заблокирован другими сигналами.

##### Синхронные и асинхронные сигналы

**Синхронные сигналы** возникают в результате выполнения текущей инструкции процеса и привязаны к конкретной точке в
коде:

- `SIGSEGV`, `SIGFPE`, `SIGILL`, `SIGTRAP`, `SIGBUS` -- обычно вызывают немедленное завершение;
- На них не создается очередь -- при попытке обработки другого синхронного сигнала из обработчика первого происходит
  двойная ошибка;
- Очень опасны для обработки, так как могут повторяться бесконечно.

**Асинхронные сигналы** порождаются внешними событиями (терминал, другой процесс, ядро) и могут быть доставлены в
произвольный момент:

- `SIGINT`, `SIGTERM`, `SIGKILL`, `SIGUSR1`, `SIGUSR2`, `SIGHUP`, `SIGCHLD` -- асинхронные;
- На стандартные сигналы не создается очередь (если сигнал уже отложен, повторный игнорируется);
- На realtime-сигналы (SIGRTMIN..SIGRTMAX) создается очередь -- каждый экземпляр сохраняется.

##### Как вручную из терминала вызвать у стороннего процесса segfault?

```bash
kill -SIGSEGV <pid>
kill -11 <pid>               # 11 = номер SIGSEGV
```

Программа получит сигнал и упадёт с "Segmentation fault (core dumped)" (если core-дампы разрешены).

##### Как из кода послать сигнал самому себе?

```c
#include <signal.h>

// Способ 1: kill себе
kill(getpid(), SIGUSR1);

// Способ 2: через raise (более явно)
raise(SIGUSR1);

// Способ 3: через pthread_kill (для конкретного потока)
#include <pthread.h>
pthread_kill(pthread_self(), SIGUSR1);
```

##### Как в коде программы заснуть до прихода сигнала?

```c
#include <signal.h>
#include <unistd.h>

// Способ 1: pause() -- спать вечно до первого сигнала
pause();                      // вернёт -1 и установит errno = EINTR, когда придёт сигнал

// Способ 2: sleep() -- спать с timeout-ом (может быть прервана сигналом)
sleep(10);

// Способ 3: sigsuspend() -- более контролируемый вариант (рекомендуется)
sigset_t mask;
sigemptyset(&mask);
sigsuspend(&mask);            // спать до сигнала, не в mask-е

// Способ 4: nanosleep() -- микросекундная точность
struct timespec req = {.tv_sec = 10, .tv_nsec = 0};
struct timespec rem;
nanosleep(&req, &rem);        // rem содержит оставшееся время при прерывании
```

Обычно используется вместе с обработчиком сигналов:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

volatile sig_atomic_t got_signal = 0;

void handler(int sig) {
    got_signal = 1;
}

int main() {
    signal(SIGUSR1, handler);
    
    printf("Жду сигнала...\\n");
    pause();                    // заснуть до SIGUSR1
    
    printf("Получен сигнал, продолжаю работу\\n");
    return 0;
}
```

Запуск:

```bash
./prog &
kill -SIGUSR1 <pid>
```
