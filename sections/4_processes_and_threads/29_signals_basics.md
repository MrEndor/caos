##### Что такое сигналы?

**Сигналы** -- это асинхронные уведомления для процесса об определённых событиях. Это "мягкие прерывания" от ОС. Когда
процесс получает сигнал:

1. его текущее выполнение **приостанавливается**;
2. **вызывается обработчик сигнала** (если установлен), либо выполняется действие по умолчанию;
3. после обработчика выполнение **продолжается**.

Сигналы используются для:

- завершения процесса (`SIGTERM`, `SIGKILL`);
- приостановки/возобновления (`SIGSTOP`, `SIGCONT`);
- отладки (SIGTRAP);
- обработки ошибок (SIGSEGV, SIGFPE);
- синхронизации между процессами.

##### Как послать сигнал процессу из терминала, а также из кода программы?

**Из терминала:**

```bash
kill -SIGTERM <pid>         # отправить SIGTERM (15)
kill -9 <pid>               # отправить SIGKILL (9)
kill -STOP <pid>            # отправить SIGSTOP (19)
kill -CONT <pid>            # отправить SIGCONT (18)

# Или через killall
killall -TERM prog_name
```

**Из кода:**

```c
#include <signal.h>
#include <unistd.h>

// Отправить сигнал другому процессу
kill(12345, SIGTERM);          // SIGTERM к процессу 12345
kill(12345, SIGUSR1);          // пользовательский сигнал 1

// Отправить сигнал целой группе процессов
kill(-12345, SIGTERM);         // минус -- это группа процессов

// Отправить сигнал всем процессам пользователя (требует прав)
kill(-1, SIGTERM);
```

##### Перечислите известные вам стандартные сигналы с объяснением, для чего они применяются.

| Номер | Имя              | Описание                                 | Действие по умолчанию |
|-------|------------------|------------------------------------------|-----------------------|
| 1     | SIGHUP           | Разрыв связи с терминалом                | Завершить             |
| 2     | SIGINT           | Interrupt (Ctrl+C)                       | Завершить             |
| 3     | SIGQUIT          | Quit (Ctrl+\\)                           | Завершить + core dump |
| 9     | SIGKILL          | Убить процесс (нельзя перехватить)       | Завершить             |
| 11    | SIGSEGV          | Segmentation fault (плохой адрес памяти) | Завершить + core dump |
| 15    | SIGTERM          | Graceful termination                     | Завершить             |
| 19    | SIGSTOP          | Остановить процесс (нельзя перехватить)  | Остановить            |
| 18    | SIGCONT          | Продолжить выполнение                    | Продолжить            |
| 8     | SIGFPE           | Floating point exception (деление на 0)  | Завершить + core dump |
| 4     | SIGILL           | Illegal instruction                      | Завершить + core dump |
| 10    | SIGUSR1, SIGUSR2 | Пользовательские сигналы                 | Завершить             |

##### Какова стандартная реакция процессов на каждый из сигналов?

По умолчанию:

- **SIGKILL, SIGSTOP** -- нельзя перехватить (ядро сразу выполняет действие);
- **SIGSEGV, SIGFPE, SIGILL** -- завершают процесс с core dump;
- **SIGTERM, SIGINT** -- завершают процесс;
- **SIGCONT** -- возобновляет остановленный процесс;
- **SIGUSR1, SIGUSR2** -- по умолчанию завершают (но часто перехватываются программой для своих целей);
- **SIGCHLD** -- по умолчанию игнорируется (используется для мониторинга дочерних процессов).

##### Как вручную из терминала вызвать у стороннего процесса segfault?

```bash
kill -SIGSEGV <pid>
kill -11 <pid>               # 11 = номер SIGSEGV
```

Программа получит сигнал и упадёт с "Segmentation fault (core dumped)" (если core-дампы разрешены).

##### Как из кода послать сигнал самому себе?

```c
#include <signal.h>

// Способ 1: kill себе
kill(getpid(), SIGUSR1);

// Способ 2: через raise (более явно)
raise(SIGUSR1);

// Способ 3: через pthread_kill (для конкретного потока)
#include <pthread.h>
pthread_kill(pthread_self(), SIGUSR1);
```

##### Как в коде программы заснуть до прихода сигнала?

```c
#include <signal.h>
#include <unistd.h>

// Способ 1: pause() -- спать вечно до первого сигнала
pause();                      // вернёт -1, когда придёт сигнал

// Способ 2: sleep() -- спать с timeout-ом (может быть прервана сигналом)
sleep(10);

// Способ 3: sigsuspend() -- более контролируемый вариант
sigset_t mask;
sigemptyset(&mask);
sigsuspend(&mask);            // спать до сигнала, не в mask-е

// Способ 4: nanosleep() -- микросекундная точность
struct timespec req = {.tv_sec = 10, .tv_nsec = 0};
struct timespec rem;
nanosleep(&req, &rem);        // rem содержит оставшееся время при прерывании
```

Обычно используется вместе с обработчиком сигналов:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handler(int sig) {
    printf("Получил сигнал %d\n", sig);
}

int main() {
    signal(SIGUSR1, handler);
    
    printf("Жду сигнала...\n");
    pause();                    // заснуть до SIGUSR1
    
    printf("После сигнала\n");
    return 0;
}
```

Запуск:

```bash
./prog &
kill -SIGUSR1 <pid>
```
