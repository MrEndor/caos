##### Какие бывают состояния у процессов?

**Состояния процесса в Linux:**

1. **Running (R)** -- процесс выполняется или находится в очереди на выполнение;
2. **Interruptible Sleep (S)** -- процесс спит, ждёт события (сигнала, I/O, таймера); может быть прерван сигналом;
3. **Uninterruptible Sleep (D)** -- процесс ждёт (обычно I/O), **не может быть прерван** сигналом; если процесс "завис",
   часто встречается этот статус;
4. **Stopped (T)** -- процесс остановлен (например, получил `SIGSTOP`);
5. **Zombie (Z)** -- процесс завершился, но родитель ещё не прочитал его статус через `wait()`.

Кроме того, помимо состояния самого процесса можно увидеть и дополнительную информацию (индикатор), которая следует
сразу за символом состояния:

1. < (High Priority) -- процесс имеет высокий приоритет (отрицательное nice).
2. N (Low Priority) -- процесс имеет низкий приоритет (положительное nice).
3. I -- процесс бездействует (спит) более 20 секунд
4. s -- процесс является лидером сессии
5. \+ -- процесс работает на переднем плане
6. l -- процесс имеет страницы, заблокированные в памяти
7. w -- процесс находится на swapfile, т.е. выгружен из ОЗУ

Посмотреть состояния:

```bash
ps aux                 # столбец STAT показывает состояние
ps -eo pid,state,comm
```

Вывод может быть: `R` (Running), `S` (Sleep), `D` (Disk sleep), `T` (Stopped), `Z` (Zombie) и т.д.

##### Как в терминале приостановить процесс, как возобновить приостановленный процесс?

Приостановить:

```bash
# Из терминала, где работает процесс:
Ctrl+Z                    # отправляет SIGSTOP

# Или отправить сигнал извне:
kill -STOP <pid>
kill -19 <pid>            # SIGSTOP = сигнал 19
```

Возобновить:

```bash
# Продолжить в foreground:
fg                        # если процесс был остановлен в текущей shell

# Или отправить сигнал:
kill -CONT <pid>
kill -18 <pid>            # SIGCONT = сигнал 18

# В background:
bg
```

##### Как пользоваться командами fg и bg?

**fg** (foreground) -- перевести процесс в foreground (он получает контроль над терминалом):

```bash
./prog &                  # запустить в background (возвращает [job_id] PID)
fg %1                     # привести job 1 в foreground
fg %prog                  # привести процесс prog в foreground
```

**bg** (background) -- возобновить остановленный процесс в background:

```bash
Ctrl+Z                    # остановить текущий процесс
bg                        # возобновить в background
# или
bg %1
```

**Примеры:**

```bash
./long_prog               # долгая программа
Ctrl+Z                    # Stopped
bg                        # возобновляется в background
fg                        # если нужно вернуть в foreground
```

##### Что такое процессы-зомби, как они возникают?

**Зомби (Zombie Process)** -- процесс, который завершился, но родитель ещё не прочитал его статус через `wait()` или
`waitpid()`.

**Когда возникают:**

- дочерний процесс завершился (вызвал `exit` или получил сигнал, приводящий к завершению);
- родитель **не вызывал** `wait()` или `waitpid()` для чтения статуса дочернего;
- в таблице процессов остаётся "труп" с PID и статусом завершения, ожидающий чтения.

**Пример:**

```c
#include <unistd.h>

int main() {
    pid_t child = fork();

    if (child == 0) {
        printf("I am child");
        // Дочерний процесс
        return 42;  // Завершается
    } else {
        // Родитель ничего не делает, спит
        getchar();
    }
}
```

**Как посмотреть зомби:**

```bash
ps aux | grep Z           # строки со статусом Z
ps -eo pid,state,ppid,comm  # все процессы и их статусы
```

**Как избежать зомби:**

- Вызывать `wait()` или `waitpid()` в родителе;
- Либо игнорировать `SIGCHLD`: `signal(SIGCHLD, SIG_IGN)`.

**Опасность:** много зомби могут заполнить таблицу процессов и помешать созданию новых процессов. Зомби занимают очень
мало памяти (только структуру в ядре), главная проблема -- истощение лимита на количество процессов.

##### Как посмотреть, в каком состоянии находится сейчас какой-либо процесс?

```bash
ps -o pid,state,comm <pid>
ps -p <pid> -o state

# Детальнее:
cat /proc/<pid>/status | grep State
```

##### Что делает сисколл wait, как им пользоваться? Что делает функция sleep в Си?

**wait()** -- ждёт завершения **любого** дочернего процесса:

```c
#include <sys/wait.h>

int status;
pid_t child_pid = wait(&status);  // блокирует до завершения дочернего

if (WIFEXITED(status)) {
    printf("Дочерний завершился с кодом %d\n", WEXITSTATUS(status));
} else if (WIFSIGNALED(status)) {
    printf("Дочерний убит сигналом %d\n", WTERMSIG(status));
}
```

**waitpid()** -- ждёт **конкретного** дочернего:

```c
int status;
pid_t child_pid = waitpid(-1, &status, 0);  // -1 = любой дочерний
waitpid(12345, &status, 0);                  // конкретный PID
waitpid(-1, &status, WNOHANG);               // неблокирующий вариант
```

**sleep()** -- приостанавливает процесс на **N секунд**:

```c
#include <unistd.h>

sleep(5);     // спать 5 секунд
usleep(500);  // спать 500 микросекунд (deprecated, используйте nanosleep)
```

Может быть прервана сигналом. Более точный вариант:

```c
#include <time.h>

struct timespec req = {.tv_sec = 5, .tv_nsec = 0};
nanosleep(&req, NULL);  // спать 5 секунд
```
