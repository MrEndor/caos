##### Расскажите про сисколлы fork и exec. Какие версии сисколла exec существуют и в чем разница между ними?

**fork** -- создаёт **новый процесс** как полную копию текущего (дочерний процесс). После `fork`:

- родитель и потомок работают параллельно;
- дочерний процесс получает копию памяти, файловых дескрипторов и т.д.;
- у обоих одинаковый код, но разные PID и PPID.

Пример:

```c
#include <unistd.h>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        // Дочерний процесс (pid == 0)
        printf("Child: мой PID = %d\n", getpid());
    } else if (pid > 0) {
        // Родительский процесс (pid == PID ребёнка)
        printf("Parent: ребёнка создал, его PID = %d\n", pid);
    } else {
        // Ошибка
        perror("fork failed");
    }
    
    return 0;
}
```

**exec** -- **заменяет образ процесса** новым (не создаёт нового процесса). После `exec`:

- текущий PID **не меняется**;
- загружается новая программа, стек и куча очищаются;
- память, файловые дескрипторы наследуются (по умолчанию);
- управление **не возвращается** (если успешно).

Версии `exec`:

- `execl(path, arg0, arg1, ..., NULL)` -- аргументы в виде списка;
- `execv(path, argv[])` -- аргументы в виде массива;
- `execle(path, arg0, ..., NULL, envp[])` -- с переданием своего `envp`;
- `execve(path, argv[], envp[])` -- системный вызов (остальные -- обёртки);
- `execlp(file, ...)` -- ищет `file` в `PATH`;
- `execvp(file, argv[])` -- аналог `execlp`, но с массивом.

##### В чем необычность функций fork и exec, что происходит при их вызове?

**fork:**

- **возвращает 2 раза**: один раз в родителе (с PID ребёнка), один раз в дочернем (с 0);
- **копирует адресное пространство**: при Copy-on-Write (CoW) физически копируется только при первой модификации;
- **не блокирует мьютексы**: все мьютексы дочерний процесс наследует в "незаблокированном" состоянии (может привести к
  deadlock, если были заблокированы).

**exec:**

- **не возвращает управление** (если успешно): текущий процесс полностью заменяется;
- **сохраняет PID, файловые дескрипторы, сигнальные обработчики**;
- **обрабатывает флаг `FD_CLOEXEC`**: файловые дескрипторы с этим флагом закрываются при `exec`;
- **очищает стек и кучу**.

##### Покажите пример вызова из программы другой программы, используя fork+exec.

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>

int main() {
    pid_t child = fork();
    
    if (child == 0) {
        // Дочерний процесс: запустить другую программу
        execl("/bin/ls", "ls", "-la", "/tmp", NULL);
        
        // Если execl вернулась, значит ошибка
        perror("execl failed");
        return 1;
    } else if (child > 0) {
        // Родительский процесс: ждать завершения дочернего
        int status;
        waitpid(child, &status, 0);
        
        if (WIFEXITED(status)) {
            printf("Child exited with code %d\n", WEXITSTATUS(status));
        }
    } else {
        perror("fork failed");
        return 1;
    }
}
```

Выполнение программы создаст дочерний процесс, который запустит `ls -la /tmp` под своим PID.

##### Что такое fork-бомба?

**Fork-бомба** -- это программа, которая создаёт процессы со скоростью, превышающей возможность их завершения, быстро
исчерпывая ресурсы системы (особенно лимит на количество процессов).

Пример (опасно! только в защищённой среде):

```c
#include <unistd.h>

int main() {
    while (1) {
        fork();
    }
    return 0;
}
```

Два дочерних процесса также `fork`'ают, получается экспоненциальный рост. За пару секунд система станет неответной.

**Защита:**

- лимиты на количество процессов (`ulimit -u`);
- cgroups (контролировать ресурсы группы процессов);
- kernel-параметр `pid_max`;
- изоляция в контейнерах или виртуальных машинах.
