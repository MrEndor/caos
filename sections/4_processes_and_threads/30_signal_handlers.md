##### Как сделать кастомный обработчик сигналов?

**Способ 1: signal()** (старый, простой, но не очень надёжный):

```c
#include <signal.h>
#include <stdio.h>

void my_handler(int sig) {
    printf("Получил сигнал %d\n", sig);
}

int main() {
    signal(SIGUSR1, my_handler);    // установить обработчик
    
    pause();                         // ждать сигнала
    return 0;
}
```

**Способ 2: sigaction()** (новый, рекомендуемый):

```c
#include <signal.h>
#include <stdio.h>

void my_handler(int sig, siginfo_t *info, void *context) {
    printf("Сигнал %d от процесса %d\n", sig, info->si_pid);
}

int main() {
    struct sigaction sa;
    sa.sa_sigaction = my_handler;     // обработчик (с доп. аргументами)
    sa.sa_flags = SA_SIGINFO;         // требуется для sa_sigaction
    sigemptyset(&sa.sa_mask);         // какие сигналы блокировать
    
    sigaction(SIGUSR1, &sa, NULL);
    
    pause();
    return 0;
}
```

##### Покажите на примере, как из кода программы перехватывать segfault и делать что-то нестандартное при его наступлении.

```c
#define _GNU_SOURCE
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

void segfault_handler(int sig, siginfo_t *info, void *context) {
    write(STDERR_FILENO, error_msg, strlen(error_msg));
    write(STDERR_FILENO, "\\n", 1);

    // Можно попытаться восстановиться, но это опасно
    // Обычно просто логируем и завершаемся
    _exit(1);
}

int main() {
    struct sigaction sa;
    sa.sa_sigaction = segfault_handler;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
 
    sigaction(SIGSEGV, &sa, NULL);
 
    printf("Установлен обработчик SIGSEGV\n");
 
    // Попытка dereferencia null pointer
    int *ptr = NULL;
    printf("Пытаюсь записать...\\n");
    *ptr = 42;      // SIGSEGV!

    printf("Это не выполнится\\n");
    return 0;
}
```

Хотя в реальной программе восстановление после SIGSEGV опасно -- лучше просто логировать и завершаться.

##### Как физически происходит, что процессу был послан сигнал?

С точки зрения процессора, происходит прерывание.

Есть ряд ячеек процессора, в которые пишется номер ошибки. В самом начале исполнения программы, создается отображения
кода ошибки в адрес функции-обработчика, находящейся в ядре ОС.
Обрабочник из ядра ОС, таким образом, перехватывает процесс:

- Если у программы настроен обработчик, то вызывается определенная функция и управление передается обратно процессу.
- Обработчик настраивается через специальный syscall.
- Если же обработчик не настроен, то ОС процессу судья.

**Подробнее:**
Когда ядро решает доставить сигнал процессу, оно:

1. Проверяет маску блокировки сигналов процесса (`sigprocmask`).
2. Если сигнал не заблокирован и есть обработчик, ядро сохраняет контекст процесса и переключает выполнение на
   обработчик.
3. После возврата из обработчика восстанавливается исходный контекст.

https://github.com/AlexSavelev/caos_course_notes/blob/main/Processes%20and%20signals.md#41-%D0%BA%D0%B0%D0%BA-%D1%84%D0%B8%D0%B7%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8-%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D1%87%D1%82%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%83-%D0%B1%D1%8B%D0%BB-%D0%BF%D0%BE%D1%81%D0%BB%D0%B0%D0%BD-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB

##### Что, если во время обработки сигнала приходит другой сигнал?

По умолчанию:

1. **Если одинаковый сигнал приходит во время его обработки:**
    - На стандартные сигналы: второй экземпляр **игнорируется** (очередь не создается);
    - На realtime-сигналы (SIGRTMIN..SIGRTMAX): сигнал **добавляется в очередь** и обрабатывается после;
    - При входе в обработчик сигнала сам этот сигнал **автоматически блокируется**.

2. **Если другой сигнал:**
    - Обычно происходит **вложенная обработка**: новый сигнал прерывает текущий обработчик и выполняется новый, потом
      возврат в первый;
    - Это **может привести к ошибкам**, если обработчики используют общие структуры данных.

Это **может привести к ошибкам**, если обработчики используют общие структуры данных.

##### Как можно заблокировать получение других сигналов во время обработки сигнала?

**Метод 1: Через маску блокировки в `sigaction`:**

```c
#include <signal.h>
#include <stdio.h>

void handler(int sig) {
    printf("Обработка сигнала %d\\n", sig); // bruh
    sleep(1);
}

int main() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = handler;
 
    // Установить маску: какие сигналы блокировать во время обработки
    sigemptyset(&sa.sa_mask);
    sigaddset(&sa.sa_mask, SIGUSR2);      // заблокировать SIGUSR2
    sigaddset(&sa.sa_mask, SIGUSR1);      // заблокировать SIGUSR1 (автоматически)
 
    sa.sa_flags = 0;
 
    sigaction(SIGUSR1, &sa, NULL);
 
    pause();
    return 0;
}
```

Во время обработки SIGUSR1 сигналы SIGUSR2 и SIGUSR1 будут **отложены** и обработаны после выхода из обработчика.

**Метод 2: Блокировать ВСЕ сигналы:**

```c
struct sigaction sa;
memset(&sa, 0, sizeof(sa));
sa.sa_handler = handler;

sigfillset(&sa.sa_mask);              // заблокировать все сигналы
sa.sa_flags = 0;

sigaction(SIGUSR1, &sa, NULL);
```

**Метод 3: Управление маской в самом обработчике (более редко):**

```c
void handler(int sig) {
    sigset_t mask, old_mask;
    sigfillset(&mask);                  // заблокировать все
    sigprocmask(SIG_BLOCK, &mask, &old_mask);
 
    // Критическая секция -- никакие сигналы не будут доставлены
 
    sigprocmask(SIG_SETMASK, &old_mask, NULL);  // восстановить старую маску
}
```

##### Что, если сигнал приходит во время выполнения сисколла?

Результат зависит от сисколла и флагов обработчика:

1. **Медленные сисколлы** (read, write, wait и т.д.):
    - обычно **прерываются**, возвращают `-1` с `errno = EINTR`;
    - нужна **перезагрузка** сисколла в цикле.

2. **С флагом `SA_RESTART`** -- ядро автоматически перезагружает прерванный сисколл.

Пример обработки `EINTR`:

```c
#include <unistd.h>
#include <errno.h>

while (1) {
    ssize_t n = read(fd, buf, size);
    if (n == -1 && errno == EINTR) {
        continue;                       // перезагрузить read
    }
    if (n == -1) {
        perror("read failed");
        break;
    }
    // обработать данные
}
```

Или с `SA_RESTART`:

```c
sa.sa_flags = SA_RESTART;              // ядро перезагрузит сисколл
sigaction(SIGUSR1, &sa, NULL);
```

##### Что такое signal-safety и что такое реентрабельная функция?

**Signal-safe функция** -- функция, которая может быть
безопасно вызвана из обработчика сигнала. Функция является signal-safe, потому что:

- **либо она реентрабельна** (не использует глобальное/статическое состояние),
- **либо её выполнение атомично относительно сигналов**
  (не может быть прервано во время выполнения).

Примеры: `write`, `read`, `_exit`, `signal`, `kill`.
НЕ signal-safe: `printf`, `malloc`, `free` (используют внутренние блокировки).

**Реентрабельная функция** -- функция, которая может быть прервана в любой точке
и затем вызвана снова (заново инициирована) до завершения предыдущего вызова,
и при этом работает корректно. Реентрабельность требует, чтобы функция **не использовала
глобальное или статическое состояние**.

**Важно:** Реентрабельность != Потокобезопасность

- Реентрабельная функция = может быть прервана и переинициирована (рекурсия, сигналы)
- Потокобезопасная функция = может быть вызвана из разных потоков (с мьютексами)
- Все реентрабельные функции = потокобезопасные (но не наоборот!)

Пример **не-реентрабельной** функции:

```c
char *my_strtok(const char *str, const char *delim) {
    static char *buffer = NULL;  // проблема!
    // ...
}
```

Вызовите из основного кода, а во время выполнения обработчик сигнала вызовет ту же функцию -- будут проблемы.

**Правило для обработчиков сигналов:**

- использовать только signal-safe функции;
- избегать динамической памяти (`malloc`, `free`);
- не вызывать обычные функции `libc`;
- установить флаги и выйти (или вызвать `_exit`).

Пример безопасного обработчика:

```c
volatile sig_atomic_t got_signal = 0;

void safe_handler(int sig) {
    got_signal = 1;          // только простое присваивание
}

int main() {
    signal(SIGUSR1, safe_handler);
 
    while (!got_signal) {
        pause();
    }
 
    // Здесь безопасно делать всё что угодно
    printf("Обработано в основном коде\n");
    return 0;
}
```
