# Раздел 3
## 17.
##### Виртуальная память. Что это такое и зачем нужно?
> **Виртуальная память** — это механизм управления памятью в современных операционных системах. Она создаёт абстракцию, при которой каждый процесс видит своё изолированное адресное пространство, а ОС отвечает за преобразование виртуальных адресов в физические.
###### Зачем это нужно
1. **Изоляция процессов**:  
   Каждый процесс работает в своём виртуальном адресном пространстве, что предотвращает доступ к памяти других процессов.

2. **Разделение и защита памяти**:  
   Общие данные (например, библиотеки) могут быть мапированы в адресное пространство нескольких процессов, оставаясь защищёнными от несанкционированной записи.

3. **Эффективное использование памяти**
##### Что такое страничная организация памяти, таблицы страниц, как они устроены и где хранятся?
> **Страничная организация памяти** — это способ управления виртуальной памятью, при котором виртуальное адресное пространство делится на равные блоки (страницы), а физическая память — на блоки той же длины. Размер страницы обычно составляет 4 КБ

> **Таблица страниц** — это структура данных, которая хранит информацию о том, какой физический адрес соответствует каждому виртуальному адресу. При доступе к памяти процессор использует эту таблицу для преобразования адресов.

Таблица страниц хранится в RAM и имеет иерархическую структуру
Адрес страницы (52 бита) разбивается на несколько кусков. Количество кусков = количество уровней в B-дереве. На картинке 4 куска. На нижнем уровне хранятся физические адреса (или ничего, если адреса нет в отображении)
Также хранит права доступа
![[page table.png]]
##### Что такое page fault, в чем отличие minor от major page fault?
Если при page walk не нашелся физический адрес и в таблице страниц, и в физической памяти, происходит page fault - исключение, обрабатываемое ядром ОС.
###### 1. **Minor page fault**
- **Описание**:  
  Cобытие, возникающее, когда процесс запрашивает страницу виртуальной памяти, которая **уже находится в физической памяти**, но ещё не связана с таблицей страниц текущего процесса.
  В этом случае ОС обновляет таблицу страниц, чтобы указать, что страница доступна.

- **Пример ситуации**:
    - При создании нового процесса через `fork()` память родительского процесса не копируется сразу. Вместо этого дочерний процесс использует те же страницы в режиме только для чтения.
    - Когда один из процессов пытается изменить данные, возникает minor page fault, и ОС копирует страницу для сохранения независимости данных.

Возникает по причине того, что ОС реализует **ленивую загрузку** (lazy loading), чтобы не выделять ресурсы заранее. Например, при запуске программы ОС может не связывать все виртуальные страницы с физической памятью, а делать это только при первом обращении.
###### 2. Major page fault
- **Описание**:  
  Происходит, если запрошенная страница отсутствует не только в таблице страниц, но и в физической памяти. Тогда ОС должна загрузить страницу с диска (например, из файла подкачки или с исполняемого файла на диске) в оперативную память.

- **Пример ситуации**:  
  Процесс обращается к данным, которые давно не использовались и были выгружены в файл подкачки (swap).
##### Что такое TLB cache?
> TLB cache - специальный кэш процессора, который хранит недавно использованные соответствия виртуальных и физических адресов.
##### Как происходит обращение процессора по адресу к памяти с учетом всего вышеназванного (вопрос с открытым ответом)?
Memory management unit выполняет следующие действия:
1. Процессор пытается обратиться по виртуальному адресу
2. Если виртуальный адрес попал в нетранслируемую область, то физический адрес приравнивается к виртуальному
3. Иначе MMU пытается найти в TLB cahce запрашиваемый адрес.
   Если нашелся, то берет физический адрес из отображения
4. Иначе происходит page walk по структуре maps: если физический адрес нашелся, он загружается в TLB cache, иначе страница ищется на диске и подгружается в оперативную память
5. Проверяются права доступа. Если нет нужных прав, то segfault
6. Если page walk завершился неудачно, то page fault: процесс прерывается, ОС обрабатывает ошибку.
   Если память была запрошена, но не выделена (так как она выделяется лениво), то выдается новая страница. Иначе segfault
   ![[virtual memory.png]]
##### В какой ситуации возникает ошибка Segmentation fault и что в этой ситуации происходит на уровне ОС и процессора?
При обработке исключения page fault ядром ОС может сгенерироваться ошибка segfault, если страница не будет найдена (ОС не обещала выдать запрашиваемую страницу) или на нее будут выставлены не соответствующие права доступа. После этого процесс аварийно завершает свою работу.
## 18.
##### На какие секции делится адресное пространство процесса?
![[memory layout.png]]
##### В чем разница между секциями .data, .rodata и .bss?
- **data** - проинициализированные статические переменные
- **rodata** - read only статические переменные
- **bss** - непроинициализированные статические переменные
##### Зачем нужны сисколлы brk и sbrk?
```bash
cat /proc/$$/maps
 # 5f60b9861000-5f60b9a0d000 rw-p 00000000 00:00 0                     [heap]
 # 5f60b9a0d000 - program break
```
**brk** возвращает адрес, который в данный момент является program break.
**sbrk** позволяет отодвинуть границу program break'a. Увеличение - выделение памяти процессу, уменьшение - деаллокация. В случае успеха возвращает границу, которая была до изменения
##### Как посмотреть, как выглядит в данный момент адресное пространство процесса?
```bash
cat /proc/$(pgrep a.out)/maps
```
## 19.
##### Можно ли запросить конкретный виртуальный адрес для выделения памяти?
Да, нужно передать желаемый адрес в качестве первого параметра. Не гарантируется, что в итоге память выделится конкретно на этом адресе.
##### Почему при обращении за границу массива segfault происходит не всегда?
Если обращаемся в пределах памяти, которая была выделена программе (минимум одна страница, то есть 4Кб) и не нарушаются никакие права доступа,то segfault не происходит
##### Как с помощью mmap загрузить файл в оперативную память? Можно ли таким образом поменять файл? Зачем нужен сисколл msync?
```c++
#include <sys/mman.h>  
#include <sys/stat.h>  
#include <fcntl.h>  
#include <unistd.h>  
#include <iostream>  
  
int main() {  
  int fd = open("example.txt", O_RDONLY);  
  if (fd == -1) {  
    exit(1);  
  }  
  
  struct stat sb;  
  if (fstat(fd, &sb) == -1) {  
    exit(1);  
  }  
  
  char* data = (char*)mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);  
  if (data == MAP_FAILED) {  
    exit(1);  
  }  
  
  data[0] = 'X';  
  std::cout << data << std::endl;  
  
  if (msync(data, sb.st_size, MS_SYNC) == -1) {  
    exit(1);  
  }  
  
  if (munmap(data, sb.st_size) == -1) {  
    exit(1);  
  }  
}
```
**MAP_PRIVATE:** создается локальная копия данных, и ее изменение не повлияет на содержимое файла. Можно менять data даже с O_RDONLY
**MAP_SHARED**: можно менять файл при наличии нужных прав.

Нет гарантий, что файл поменяется сразу, так как операция ассинхронная. Поэтому**msync** синхронизирует изменения, чтобы до закрытия файла они гарантированно произошли.
## 20.
##### Какие бывают права доступа к памяти?
PROT_READ, PROT_WRITE, PROT_EXEC - права на чтение, запись, выполнение
##### Зачем нужен сисколл mprotect и как им пользоваться?
mprotect - сисколл, позволяющий изменить права доступа к памяти.
Адрес должен быть выровнен по размеру страницы.
> int mprotect(void* address, size_t len, int prot)
##### Покажите, как с помощью mmap и mprotect загрузить код из библиотеки в память на выполнение.
```c++
#include <sys/stat.h>  
#include <unistd.h>  
#include <iostream>  
#include <fcntl.h>  
#include <sys/mman.h>  
  
int main(int argc, char* argv[]) {  
  const char* file_name = argv[1];  
  double argument = strtod(argv[2], NULL);  
  
  int fd = open(file_name, O_RDONLY);  
  struct stat st = {};  
  fstat(fd, &st);  
  
  void* addr = mmap(NULL, st.st_size, PROT_READ|PROT_EXEC, MAP_PRIVATE, fd, 0);  
  double (*func)(double) = (double (*)(double)) ((char*)addr + 0x40);  
  
  close(fd);  
  double result = func(argument);  
  std::cout << argument << std::endl << result;  
  munmap(addr, st.st_size);  
}
```
нужен файл с динамической библиотекой
```c
double mysqr(double x) {  
  return x * x;  
}
```

```bash
g++ -c func.c
readelf -a func.o # смотрим на колонку align для секции .text
g++ mmap_library.cpp
./a.out func.o 5
```
##### Что означает ошибка Illegal intstruction?
Illegal intstruction - процессор начал выполнять бинарный код как ассемблерные инструкции, но при раскодировке увидел невалидные команды
## 21.
##### Как реализованы функции malloc и free в стандартной библиотеке Си? Расскажите про механизм бакетов, малые и большие бакеты. Как malloc выбирает, какой бакет использовать? Как происходит освобождение бакетов и слияние соседних свободных бакетов?
- malloc пытается минимизировать количество вызовов сисколлов sbrk и mmap
- в **MAP_THRESHOLD** записано число байтов, начиная с которого malloc **начинает использовать mmap**. Где-то используется 128 Кб
- записывает 16 байт на начало выделяемой памяти - размер выделенного куска, чтобы корректно удалить в будущем
- В самом начале мы делаем sbrk на какое-то большое число байт (например на MMAP_THRESHOLD) и тем самым обеспечиваем себе "бассейн"с уже выделенной памятью для использования в дальнейшем (между старым program break и новым). Если место заканчивается, то опять сдвигаем program break (например на 1 страницу), если это возможно.
- Храним **массив из двусвязных списков свободных чанков** размеров от 16 до 512 с интервалом 8 (small chunks), а после размеры чанков будут расти уже экспоненциально, пока не дорастут до MMAP_THRESHOLD (large chunks)
- Каждый свободный чанк лежит в двусвязном списке, хранит свой размер **в первых и последних** 4 байтах. Также хранит указатели на предыдущий свободный чанк из списка и следующий для удаления из списка за O(1).
- Каждый занятый чанк хранит свой размер в начале и конце. Посередине - занятое программой, попросившей выделить память, место
- Когда просят выделить немного памяти, то идем в структуру выше и пытаемся найти свободный блок, в который влезет выделяемое содержимое (то есть по размеру минимальный больше равный). Если не находим, то откусываем от нашего хранилища блок того размера, которого мы не смогли найти в свободных чанках. Помимо этого запомним, что теперь наше хранилище начинается позже, так как его начало ушло на новый чанк.
- Когда освобождается чанк в этом хранилище, то информация о размерах, записанная в конце, позволяет объединять чанк со своими соседями, перед тем, как возвращать его в список свободных чанков (размер кратен 8, а значит последний бит размера можно использовать для индицирования занятости блока). Чанк добавляется в массив
##### Что такое fastbins?
fastbins – только что освобождённые small chunks. Утверждается, что если вы освободили кусок какого-то размера, то скорее всего вы скоро попросите выделить кусок такого же размера.
После удаления и перед тем как добавить в массив, их связывают в отдельный список. И когда запрашивают сколько-то байт, то сначала проверяются чанки из fastbins. Если там не удалось найти подходящего (best suit) чанка, то fastbins очищается и чанки раскидываются по алгоритму по своим бакетам в массив.
##### Какие сисколлы использует malloc для работы с памятью?
malloc использует в основном 2 сисколла – brk (sbrk) для небольших размеров и mmap для значительных запросов.