##### Формат ELF.

**ELF (Executable and Linkable Format)** -= стандартный бинарный формат в Linux. Один и тот же формат используется для
объектных файлов, исполняемых файлов, библиотек и core‑дампов.

##### Какие типы ELF-файлов существуют? Покажите по одному примеру каждого типа.

1. **REL (Relocatable file)** -- объектный файл:
   ```bash
   g++ -c main.cpp -o main.o
   readelf -h main.o   # тип REL
   ```

2. **EXEC (Executable file)** -- классический не‑PIE исполняемый файл:
   ```bash
   g++ -static main.cpp -o main_static
   readelf -h main_static   # тип EXEC
   ```

3. **DYN (Shared object file)** -- разделяемый объект:
    - динамическая библиотека:
      ```bash
      g++ -shared -fPIC lib.cpp -o libfoo.so
      readelf -h libfoo.so   # тип DYN
      ```
    - позиционно‑независимый исполняемый файл (PIE) -- современные бинарники `g++ main.cpp` часто тоже имеют тип DYN.

4. **CORE (Core file)** -- дамп памяти упавшего процесса:

##### Из каких основных секций состоят ELF-файлы?

Часто встречающиеся секции:

- `.text` -- машинный код программы;
- `.data` -- инициализированные глобальные/статические переменные;
- `.rodata` -- константные данные (строки, литералы и т.п.);
- `.bss` -- неинициализированные глобальные/статические переменные (занимают место только в памяти, а не в файле);
- `.symtab` -- полная таблица символов (для линковки и отладки);
- `.dynsym` -- таблица динамических символов (для динамического линковщика);
- `.rel.*` / `.rela.*` -- таблицы релокаций;
- `.strtab` -- строковая таблица имён символов, на которые ссылается `.symtab`;
- `.shstrtab` -- строковая таблица имён секций (`.text`, `.data` и т.п.);
- `.interp` -- путь к динамическому загрузчику (`/lib64/ld-linux-x86-64.so.2` и т.п.);
- `.dynamic` -- массив структур `Elf*_Dyn` с параметрами динамической линковки (список нужных библиотек, rpath/runpath,
  адреса таблиц и т.д.);
- `.plt`, `.got`, `.got.plt` -- инфраструктура для позднего связывания вызовов функций в динамических библиотеках.

##### Что хранится в секциях strtab, shstrtab, interp, dynamic?

- `.strtab` -- строки с именами символов (функций, переменных), на которые ссылается `.symtab`.
- `.shstrtab` -- строки с именами **секций** (`.text`, `.data`, `.bss` и т.д.).
- `.interp` -- нуль‑терминированная строка с путём к динамическому линковщику; ядро читает её при запуске.
- `.dynamic` -- записи `Elf*_Dyn`: каждая задаёт один параметр динамической линковки (какие библиотеки нужны, где
  находятся таблицы релокаций, rpath, размер таблиц и т.д.).

Важно различать **секции** (file view, для линковщика) и **сегменты**/program headers (run‑time view, для загрузчика).
Загрузчик смотрит именно на program headers (`PT_LOAD`, `PT_DYNAMIC`, `PT_INTERP`) и по ним мапит участки файла в
память.

##### Какие есть утилиты для чтения содержимого ELF-файлов? Для чего нужна утилита objcopy? Приведите пример использования.

- `readelf` (работает напрямую с ELF‑структурами):
  ```bash
  readelf -h a.out   # заголовок
  readelf -S a.out   # секции
  readelf -s a.out   # таблица символов
  readelf -d a.out   # динамическая секция
  ```

- `objdump`:
  ```bash
  objdump -d a.out   # дизассемблер
  objdump -x a.out   # заголовок + секции + символы
  ```

- `nm` -- список символов:
  ```bash
  nm a.out
  nm -D a.out        # динамические символы
  ```

- `file` -- краткая информация о типе ELF:
  ```bash
  file a.out
  ```

**Для чего нужна `objcopy` и пример использования:**

`objcopy` умеет копировать ELF‑файлы, выбирая/удаляя секции и/или меняя формат. Типичные сценарии:

- получить 'голый' бинарный дамп кода из ELF (например, для прошивки микроконтроллера):
  ```bash
  objcopy -O binary a.out a.out.bin
  ```

- вытащить только секцию `.text` в отдельный файл:
  ```bash
  objcopy --only-section=.text -O binary a.out text.bin
  ```

- удалить таблицу символов и отладочную информацию (почти как `strip`, но более гибко).
