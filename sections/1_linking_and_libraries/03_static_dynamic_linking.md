##### Что такое статическая и динамическая линковка, статические и динамические либы?

**Статическая vs динамическая линковка:**

- При **статической линковке** код нужных функций из статических библиотек (`.a`) физически **встраивается** в итоговый
  исполняемый файл.  
  Бинарь становится крупнее, но может запускаться на системе без соответствующих `.so`.

- При **динамической линковке** бинарь содержит только информацию о зависимостях и таблицы для позднего связывания.  
  При запуске динамический линковщик подгружает нужные `.so` (по полям `DT_NEEDED` в `.dynamic`), выполняет релокации и
  настраивает PLT/GOT.

**Статические и динамические библиотеки:**

- статические: `libfoo.a` -- архив объектных файлов;
- динамические: `libfoo.so` -- ELF DYN, разделяемый объект.

##### Как принудительно сделать статическую линковку вместо динамической и зачем это бывает нужно?

```bash
g++ -static main.cpp -o main_static
```

Зачем это бывает нужно:

- запуск на машинах, где нет нужных версий библиотек;
- поставка одного самодостаточного бинаря (например, в контейнер без дистрибутива (distroless) или на такой же 'голый'
  сервер);
- контроль над используемыми версиями библиотек.

При этом `ldd main_static` обычно ответит `not a dynamic executable`.

##### Что делает команда ldd и как она работает?

```bash
ldd ./prog
```

Показывает, какие динамические библиотеки (`.so`) будет загружать данный бинарь:

- имя библиотеки;
- путь, откуда она берётся;
- адрес загрузки.

Фактически запускается тот же динамический линковщик с переменной `LD_TRACE_LOADED_OBJECTS=1`: вместо реального запуска
он только печатает информацию о загруженных объектах.

Вы сами можете вывести все зависимости

```bash
 LD_TRACE_LOADED_OBJECTS=1 ./main
```

Вывод

```
    linux-vdso.so.1 (0x00007fd247062000)
    libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x00007fd246c00000)
    libc.so.6 => /usr/lib/libc.so.6 (0x00007fd246a10000)
    libm.so.6 => /usr/lib/libm.so.6 (0x00007fd246f3c000)
    /lib64/ld-linux-x86-64.so.2 (0x00007fd247064000)
    libgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007fd246f0f000)
```

##### Как собрать программу с либой C++, расположенной по нестандартному адресу?

Пусть `libstdc++.so` лежит в `/opt/mylibs`.

```bash
g++ main.cpp -L/opt/mylibs -lstdc++ -Wl,-rpath,/opt/mylibs -o main
```

- `-L/opt/mylibs` -- где искать библиотеку при линковке;
- `-Wl,-rpath,/opt/mylibs` -- зашить путь поиска в сам бинарь для динамического линковщика.

##### Как создать свою динамическую либу и собрать программу с ее использованием?

`lib.cpp`:

```cpp
#include <iostream>

void hello() {
    std::cout << "Hello from lib\n";
}
```

Сборка `.so`:

```bash
g++ -fPIC -shared lib.cpp -o libmy.so
```

`main.cpp`:

```cpp
void hello();

int main() {
    hello();
    return 0;
}
```

Линковка и запуск (вариант с `LD_LIBRARY_PATH`):

```bash
g++ main.cpp -L. -lmy -o main
LD_LIBRARY_PATH=. ./main
```

Либо зашить путь через rpath:

```bash
g++ main.cpp -L. -lmy -Wl,-rpath,. -o main
./main
```

##### Для чего нужны переменные LD_PRELOAD, LD_LIBRARY_PATH?

- `LD_LIBRARY_PATH` -- список директорий (через `:`), которые динамический линковщик ищет **до** стандартных путей:
  ```bash
  LD_LIBRARY_PATH=/opt/mylibs:./lib ./prog
  ```
  Удобно, если библиотеки лежат в нестандартном месте.

- `LD_PRELOAD` -- список `.so`, которые нужно подгрузить **раньше остальных** и чьи символы будут иметь приоритет. Это
  позволяет перехватывать функции (`open`, `malloc`, `read` и т.д.):
  ```bash
  LD_PRELOAD=./override_malloc.so ./prog
  ```

##### Что такое rpath и как его использовать?

`rpath` -- поле в ELF, в котором хранится список директорий, где динамический линковщик должен искать библиотеки для
этого бинаря.

Задаётся на стадии линковки:

```bash
g++ main.cpp -L/opt/mylibs -lmy -Wl,-rpath,/opt/mylibs -o main
```

В результат попадает запись `DT_RUNPATH`/`DT_RPATH` в `.dynamic`, и бинарь можно запускать без `LD_LIBRARY_PATH`.

##### Как посмотреть, какие вызовы библиотечных функций делает данная программа в ходе выполнения?

Используется `ltrace`:

```bash
ltrace ./prog
```

Он показывает вызовы функций из динамических библиотек (libc, libstdc++ и т.п.) с аргументами и возвращаемыми
значениями. Для системных вызовов используется `strace`.
