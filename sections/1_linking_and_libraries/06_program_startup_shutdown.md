##### Запуск программы.

##### Что происходит при запуске бинаря до начала функции main, а также после ее окончания (вопрос с открытым ответом, чем подробнее, тем лучше)?

**Что происходит до вызова `main`:**

1. **Ядро**:
    - читает ELF‑заголовок;
    - создаёт процесс и его адресное пространство;
    - мапит сегменты `.text`, `.data`, `.bss`, стек, кучу;
    - если ELF динамический, загружает **динамический линковщик** (путь берётся из `.interp`).

2. **Динамический линковщик**:
    - загружает все необходимые `.so` (по записям `DT_NEEDED`);
    - выполняет релокации;
    - настраивает таблицы PLT/GOT и прочие структуры.

3. Ядро передаёт управление в функцию `_start` (из `crt1.o`). Она:
    - подготавливает стек, формирует `argc`, `argv`, `envp`;
    - вызывает `__libc_start_main(main, ...)`.

4. `__libc_start_main`:
    - вызывает **конструкторы глобальных и статических объектов** (функции из `.init_array` и аналогичных секций, в том
      числе из динамических библиотек);
    - затем вызывает `main(argc, argv, envp)`.

**Что происходит после завершения `main`:**

Возврат из `main` попадает обратно в `__libc_start_main`, который:

- вызывает зарегистрированные функции `atexit`;
- вызывает **деструкторы** глобальных и статических объектов (из `.fini_array` и др.);
- завершает процесс через системный вызов `exit` / `exit_group`.

##### Кто и когда вызывает конструкторы и деструкторы глобальных объектов?

- Конструкторы глобальных и статических объектов:
    - их адреса записаны в специальных массивах (`.init_array` и т.п.);
    - вызываются до `main` в рамках `__libc_start_main` и/или динамического линковщика (для объектов внутри библиотек).

- Деструкторы:
    - записаны в `.fini_array`;
    - вызываются после завершения `main` или при явном `exit`.

##### Как попросить g++ поставить точку старта программы на конкретную функцию?

Через опцию линковщика `-e`:

```bash
g++ main.cpp other.cpp -Wl,-e,my_start -o prog
```

и реализовать:

```cpp
#include <unistd.h>

extern "C" void my_start() {
    // при желании можно явно вызвать main
    int code = main(0, nullptr);
    _exit(code);   // важно: не делать обычный return
}
```

Теперь именно `my_start` будет использоваться как точка входа вместо стандартного `_start`.

##### Почему происходит segfault, если точка старта программы выбрана неудачно?

Если в качестве `_start` использовать обычную функцию, у неё:

- нет корректно подготовленного стека (ожидаемого ABI для обычной C‑функции);
- не были вызваны конструкторы глобальных объектов;
- не выполняется нормальная процедура завершения.

Если такая функция сделает `return`, процессор попытается взять адрес возврата с "левого" стека -> переход по мусорному
адресу -> `SIGSEGV`.

##### Как сделать, чтобы segfault в таком случае не было?

- В пользовательской точке входа **не возвращаться**, а завершать процесс через `_exit`:
  ```cpp
  extern "C" void my_start() {
      // ... логика ...
      _exit(0);
  }
  ```
- Либо реализовать полный аналог стартового кода (`crt1.o`), который корректно вызывает `__libc_start_main`.
