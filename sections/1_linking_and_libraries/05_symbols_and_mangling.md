##### Что такое символы в терминах линковщика?

Символ -- именованная сущность, которая может фигурировать в линковке:

- функции;
- глобальные/статические переменные;
- иногда специальные объекты (секции, файлы).

У символа есть:

- имя;
- тип (функция, объект и т.д.);
- адрес или пометка `UND` (если определение в другом модуле);
- **binding** (local/global/weak);
- **visibility** (default/hidden/protected).

Линковщик сопоставляет **использования** символов с их **определениями** во всех объектных файлах и библиотеках.

##### Что такое манглирование и как (в общих чертах) оно работает?

В C++ есть пространства имён, перегрузка функций, методы классов, шаблоны. На уровне линковки всё это должно свестись к
уникальным строковым именам.

Компилятор кодирует (манглирует) "человеческое" имя и типы аргументов в строку по правилам ABI. Примеры для g++ (Itanium
C++ ABI):

- `int foo(int)` -> `_Z3fooi`;
- `void Ns::Bar::baz(double)` -> `_ZN2Ns3Bar3bazEd`.

##### Как по манглированному имени восстановить исходное?

```bash
echo _Z3fooi | c++filt
# int foo(int)

nm a.out | c++filt        # деманглировать сразу все символы
objdump -C -t a.out       # ключ -C включает demangle
```

##### Как посмотреть список символов в данном ELF-файле?

- через `nm`:
  ```bash
  nm a.out
  nm -D a.out       # только динамические символы
  ```

- через `readelf`:
  ```bash
  readelf -s a.out  # полная таблица символов
  readelf -sD a.out # динамические символы
  ```

- через `objdump`:
  ```bash
  objdump -t a.out
  ```

##### Что делает команда strip?

`strip` удаляет из ELF отладочную информацию и (при желании) таблицу символов. Цели:

- уменьшить размер бинаря;
- усложнить реверс‑инжиниринг;
- ускорить загрузку за счёт меньшего количества данных.

Пример:

```bash
strip a.out
```

После этого `nm a.out` почти ничего полезного не покажет.

##### Какое бывает связывание у символов (global, local и weak)?

**Виды связывания (binding) символов:**

- **STB_LOCAL (local)** -- символ виден только внутри данного объектного файла; при линковке не рассматривается как
  кандидат для удовлетворения внешних ссылок.

- **STB_GLOBAL (global)** -- глобальный символ, может использоваться и из других объектных файлов. Именно такие символы
  обычно экспортируются из библиотек.

- **STB_WEAK (weak)** -- "слабое" определение. Если найдётся глобальное определение с тем же именем, оно его
  переопределит. Если определения нет вообще, использование слабого символа может быть допустимо (например, указатель на
  функцию окажется `nullptr`).

##### Какая бывает видимость у символов (default, hidden, protected)?

- **default** -- обычная видимость, символ экспортируется наружу и может быть переопределён (interposed) другой
  библиотекой.

- **hidden** -- символ не экспортируется за пределы объекта; даже если у него глобальный binding, он остаётся
  внутренним.

- **protected** -- символ экспортируется, но не может быть переопределён другой библиотекой (адрес фиксируется
  локально).

Видимость можно задавать в исходнике (атрибуты `__attribute__((visibility("hidden")))`) или через скрипты линковщика.