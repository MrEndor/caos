##### Что такое системный вызов (сисколл)?

**Системный вызов (system call, сисколл)** -- это механизм перехода из пользовательского режима в режим ядра, через
который процесс просит ОС выполнить привилегированное действие:

- чтение/запись файлов и устройств;
- работа с сетью;
- управление памятью, процессами, таймерами и т.п.

Обычные функции стандартной библиотеки (`read`, `write`, `open`, `fork`, `execve` и др.) являются **обёртками** над
сисколлами: внутри они выполняют инструкцию `syscall` (на x86‑64) или аналогичную.

##### Как посмотреть в режиме реального времени, какие сисколлы происходят во время работы какой-нибудь программы?

С помощью `strace`:

- запустить новую программу:
  ```bash
  strace ./prog
  ```
- подключиться к уже работающему процессу по PID:
  ```bash
  strace -p 12345
  ```

Полезные опции:

- `-e trace=read,write,open` -- фильтр по интересующим сисколлам;
- `-f` -- следить также за дочерними процессами;
- `-o log.txt` -- писать лог в файл.

`strace` показывает имя сисколла, аргументы и возвращаемое значение.

##### Как посмотреть мануал для данного сисколла?

Системные вызовы документированы в **разделе 2** man‑страниц:

```bash
man 2 read
man 2 write
man 2 open
man 2 errno
```

##### Покажите использование сисколлов на примере read и write. Как использовать возвращаемые значения этих сисколлов?

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

- `fd` -- файловый дескриптор (0 -- stdin, 1 -- stdout, 2 -- stderr);
- `buf` -- указатель на буфер;
- `count` -- запрошенное количество байт.

Пример программы echo на чистых сисколлах:

```c
#include <unistd.h>
#include <errno.h>
#include <stdio.h>

int main() {
    char buf[4096];

    while (1) {
        ssize_t n = read(0, buf, sizeof(buf));   // stdin
        if (n == 0)            // EOF
            break;
        if (n == -1) {         // ошибка
            perror("read");
            return 1;
        }

        ssize_t written = 0;
        while (written < n) {
            ssize_t m = write(1, buf + written, n - written);  // stdout
            if (m == -1) {
                perror("write");
                return 1;
            }
            written += m;      // учитываем частичные записи
        }
    }

    return 0;
}
```

Особенности:

- при успехе `read` возвращает `0..count` -- сколько байт реально прочитано; `0` означает EOF;
- при успехе `write` возвращает `0..count` -- сколько байт реально записано (может быть меньше `count`, особенно на
  неблокирующих дескрипторах или сокетах);
- при ошибке оба возвращают `-1` и устанавливают глобальную (но **thread‑local**) переменную `errno`.

##### Как проверить, успешно ли был выполнен сисколл, а в случае неудачи узнать, какая ошибка произошла?

Шаблон:

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

ssize_t res = read(fd, buf, size);
if (res == -1) {
    int err = errno;               // сохранить сразу, пока не потеряли
    fprintf(stderr, "read failed: %d (%s)\n", err, strerror(err));
}
```

- `errno` содержит код ошибки (`EAGAIN`, `EINTR`, `EBADF`, `EFAULT` и т.д.);
- `perror("read")` печатает строку вида `read: <описание ошибки>`;
- `strerror(errno)` возвращает строку‑описание.

Важно помнить, что в случае частичных записей/чтений (особенно при работе с сокетами и неблокирующими дескрипторами)
нужно организовывать **циклы**, пока не будет обработан весь объём данных или не произойдёт ошибка.
