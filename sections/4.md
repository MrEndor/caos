# Раздел 4
## 22.
##### Что такое процесс?
> Процесс - запущенный исполняемый код, имеющий аттрибуты, которые навесила на него операционная система, некоторая сущность в ядре ОС.
##### Как посмотреть все процессы в системе? Что такое pid, ppid? Как посмотреть дерево процессов? Как посмотреть потребление памяти, потребление CPU каждым из процессов?
```bash
ps aux # вывести все процессы
pstree # вывести дерево процессов, или F5 в htop

htop # можно посмотреть список всех процессов с помощью утилиты htop
top # стандартная команда
```
**VIRT** - количество выделенной виртуальной памяти, **RES** - фактически занятая память
**SHR** - занятая разделяемая память (shared memory)
**CPU** - сколько процесс отъедает от ядра процессора

**PID** - id процесса
**PPID** - id родительского процесса
Можно в htop включить отображение PPID
##### Что такое приоритет процесса, какой он бывает, как его узнать и как поменять?
Посмотреть приоритет можно в htop - колонка **NI** (niceness).
**Niceness** - сколько процесс готов "уступить" процессорного времени. Чем больше NI, тем ниже приоритет. Варьируется от -20 до 20, по умолчанию 0.
Priority (PR) высчитывается на основе niceness для обычных процессов.
```bash
nice -n 10 "command" # позволяет запустить процесс с определенным NI (10)
# для отрицательного niceness нужны права root'а
renice -n 10 "command" # изменить NI у работающего процесса на 10
```
##### Что такое uid, euid и cwd данного процесса, как их узнать и как поменять?
>**uid** - id **настоящего** юзера, который запустил процесс. Определяет базовые права доступа (например, какие файлы или ресурсы может использовать процесс).
>**euid** - id юзера, от чьего имени был запущен процесс.
`Пример`: вызов sudo. У вызванной программы uid оказывается пользователя, вызвавшего sudo, а euid - id root'a
**cwd** - это **текущая рабочая директория процесса**, относительно которой выполняются операции с файлами.
###### Как узнать?
Можно при помощи htop или ps -eo pid,user,euser,cmd
###### Как изменить?
- cwd
```c
#include <unistd.h>
int main() {
    chdir("/new/directory/path");
    return 0;
}
```
- uid/euid
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    if (setuid(1001) != 0) { // seteuid
        perror("Failed to set UID");
        return 1;
    }
    return 0;
}

```
Можно изменить для работающих процессов при помощи gdb
## 23.
##### Расскажите про сисколлы fork и exec. Какие версии сисколла exec существуют и в чем разница между ними?
**fork** - создает новый процесс, дублируя процесс, который вызвал сисколл. За исключением PID старый и новый процесс неотличимы на момент создания.
Новому созданному процессу вернется 0, а старому - PID нового процесса.
```c++
// вопрос на уд на фпми
#include <iostream>
#include <unistd.h>

int main() {
  std::cout << "Hello!" << "\n";
  int pid = fork();
  if (pid == 0) {
    std::cout << "child" << "\n";
  } else {
    std::cout << "parent" << "\n";
  }
}
// вывод: 2 раза Hello, child, parent, так как буфер cout тоже копируется
```
**exec** - не сисколл если на душном. Вместо текущего процесса открывает новую программу, переданную в качестве первого аргумента, сохраняет PID старого процесса, файловые дескрипторы. Куча и стек не сохраняются

Существует несколько вариантов `exec`, которые предоставляют разные способы передачи аргументов и переменных окружения новому процессу. Все они являются оболочками вокруг одного системного вызова `execve`.
1. **execl** - передача аргументов как отдельных строк
   `int execl(const char *path, const char *arg, ..., NULL);`
   `execl("/bin/ls", "ls", "-l", NULL);`
2. **execv** - передача массива строк
   `int execv(const char *path, char *const argv[]);`
   ```c
   char *args[] = {"ls", "-l", NULL};
   execv("/bin/ls", args);`
    ```
3. **execvp** - аналог execve, но ищет исполняемый файл в системной переменной PATH
   `int execvp(const char *file, char *const argv[]);`
```c
	char *args[] = {"ls", "-l", NULL};
	execvp("ls", args);
```
И так далее, все разновидности в man 3 exec.

| **Функция** | **Передача аргументов** | **Передача переменных окружения** | **Поиск по `PATH`** |
| ----------- | ----------------------- | --------------------------------- | ------------------- |
| `execl`     | Отдельные аргументы     | Нет                               | Нет                 |
| `execv`     | Массив строк            | Нет                               | Нет                 |
| `execle`    | Отдельные аргументы     | Да                                | Нет                 |
| `execve`    | Массив строк            | Да                                | Нет                 |
| `execlp`    | Отдельные аргументы     | Нет                               | Да                  |
| `execvp`    | Массив строк            | Нет                               | Да                  |
Можно заметить, что каждая буква за что-то отвечает. p - за path, l - за передачу аргументов в качестве отдельных строк, v - передача аргументов в качестве массива, e - передача переменных окружения.
```bash
which ls # посмотреть по какому адресу находится исполняемая программа
# нужно для передачи в качестве первого аргумента execve
```
##### В чем необычность функций fork и exec, что происходит при их вызове?
хз если честно какой ответ тут ожидается, но попросить дедушку мороза (процессор) проснуться в теле другого человека, или проснуться в одном мире со своей копией (привет субстанция) ну странновато да...... тут ответ гптшки
###### `fork`:
- Уникальная концепция: Два независимых процесса начинают выполнение с одной точки.
- Сохранение ресурсов: Благодаря Copy-on-Write, `fork` эффективен даже для процессов с большим объёмом памяти.
###### `exec`:
- Замена без изменения PID: Содержание процесса полностью заменяется, но процесс остаётся тем же.
- Простота интеграции: Сохраняются открытые дескрипторы и PID, что упрощает коммуникацию между процессами.
##### Покажите пример вызова из программы другой программы, используя fork+exec.
```c++
#include <iostream>  
#include <unistd.h>  

int main() {  
  int pid = fork();  
  if (pid != 0) {  
    std::cout << "parent" << std::endl;  
    char* argv[] = {"/usr/bin/ls", "/home/liza", NULL};  
    char* envp[] = {NULL};  
    int code = execve("/usr/bin/ls", argv, envp);  
    std::cout << "code: " << code << "\n";  
    std::cout << errno << "\n";  
  } else {  
    std::cout << "child" << "\n";  
  }  
}
```
##### Что такое fork-бомба?
**Fork-bomb** — это  программа, которая бесконтрольно создаёт новые процессы через системный вызов `fork()`, пока система не исчерпает ресурсы (например, процессорное время или максимальное количество процессов). Это вызывает нарушение работы системы или её полное зависание.
```c++
#include <iostream>
#include <unistd.h>

int main() {
  while (true) {
	int pid = fork();
  }
}
```
## 24.
##### Какие бывают состояния у процессов?
man ps перечислит
- **S** - прерываемый сон, то есть ждет события, чтобы проснуться. Пример: ввод с консоли
- **D** - непрерываемый сон, выполняет критическую операцию ядра (обычно связанную с I/O)
- **T** - остановленный процесс (SIGSTOP или Ctrl+z)
- **t** - процесс остановлен отладчиком
- **Z** - зомби-процесс
- **R** - процесс выполняется или готов к выполнению
##### Как в терминале приостановить процесс, как возобновить приостановленный процесс?
Если процесс запущен в терминале, то Ctrl+z, иначе:
```bash
kill -STOP "proccess-id"
kill -CONT "proccess-id" # у меня не работает))))))))))))))))))))))))))))0
# оказалось если процесс ожидает ввода с терминала (ну в целом находится в состоянии S+, то ему может быть трудно проснуться)
# например если процесс ждал ввод, то он может не просыпаться до того момента, пока этот ввод не получит
```
##### Как пользоваться командами fg и bg?
```bash
./a.out & # запустить программу на фоне
jobs # посмотреть список фоновых процессов, запущенных в данном терминале
```
###### fg
Выводит на передний план последнюю job, запущенную в терминале
###### bg
Запускает в фоновом режиме приостановленную задачу. Можно использовать синтаксис bg 1 - запустить определенную задачу
##### Что такое процессы-зомби, как они возникают?
Процессы-зомби - завершившиеся дочерние процессы, но они продолжают жить, так как родитель еще не собрал информацию о них.
- Это происходит, если родительский процесс не вызвал `wait()` для получения статуса завершённого процесса.
- Зомби-процесс не занимает ресурсов, кроме записи в таблице процессов.
##### Как посмотреть, в каком состоянии находится сейчас какой-либо процесс?
```bash
htop # можно найти нужный процесс, колонка S
ps u -p "proccess-id" # колонка STAT
```

## 25.
##### Что такое rlimit для процесса?
> rlimit - ограничение на потребление процессором различных ресурсов. Текущие лимита процесса можно посмотреть в файле командой cat /proc/$(pgrep a.out)/limits
##### Как пользоваться функциями getrlimit и setrlimit?
Сиколлы используют структуру
```c
struct rlimit {
    rlim_t rlim_cur;  // Текущее ограничение ресурса
    rlim_t rlim_max;  // Максимально возможное ограничение ресурса
};
```

```c
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
```
**resource** задается константой - ресурс, лимит которого хотим узнать. Смотрим man 2 getrlimit. В структуре меняем меняем/смотрим нужное нам значение.
##### Как установить процессу ограничение на использование памяти и/или процессорного времени?
Можно через setrlimit установить ограничение на **RLIMIT_DATA** - вся память в совокупности, считая стек, кучу и тд, и на **RLIMIT_CPU** - время исполнения в секундах.
##### Что произойдет, если эти ограничения будут превышены?
Превышение лимитов ресурсов в системе приводит к различным ошибкам, которые можно обработать в программе, но в случае критических лимитов, таких как время процессора, операционная система может принудительно завершить процесс.

Если же пытаться выделить больше памяти, чем можно, или открыть больше файлов, то сисколлы будут возвращать ошибку и менять errno.
## 26.
##### Расскажите про библиотеку seccomp.
> **Seccomp (Secure Computing)** — это механизм в Linux, который позволяет ограничивать процесс в использовании определённых системных вызовов
Если процесс вызывает запрещённый системный вызов, происходит событие (например, `SIGSYS`), и программа завершается с ошибкой.
##### Покажите на примере, как запретить программе вызывать определенные сисколлы. Как получить ошибку Bad system call (core dumped)?
```bash
sudo apt-get install libseccomp-dev # установка библиотеки
g++ seccomp.cpp -lseccomp # линкуем либу
```

```c++
#include <seccomp.h>  
#include <unistd.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <iostream>  
  
void seccomp_setup() {  
  scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_ALLOW);  
  if (ctx == nullptr) {  
    std::cout << "seccomp_init failed" << std::endl;  
    exit(1);  
  }  
  
  if (seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(clone), 0) != 0) {  
    std::cout << "seccomp_rule_add failed" << std::endl;  
    seccomp_release(ctx);  
    exit(1);  
  }  
  
  if (seccomp_load(ctx) != 0) {  
    std::cout << "seccomp_load failed" << std::endl;  
    seccomp_release(ctx);  
    exit(1);  
  }  
  seccomp_release(ctx);  
}  
  
int main() {  
  seccomp_setup();  
  fork();  
  std::cout << errno;  
}
```

```bash 
man seccomp_init # подробную информацию можно найти в мануале
```
## 27.
##### Что такое сигналы?
> Сигналы - вид IPC (Inter Proccess Communication)
##### Как послать сигнал процессу из терминала, а также из кода программы?
```bash
kill -signal "proccess_id"
```
Есть одноименный syscall - kill. Можно использовать из программы, чтобы посылать процессам сигналы
##### Перечислите известные вам стандартные сигналы с объяснением, для чего они применяются.
- SIGHUP - подключились удаленно через ssh к серверу, запустили вычисления на нем. Если во время этого оборвется соединение, процессу на сервере придет SIGHUP. Программа по умолчанию падает. nohup позволяет продолжить работу
- SIGABRT - сигнал от abort()
- SIGCHLD - посылается родителю, когда ребенок завершился
- SIGCONT - сигнал продолжения работы процесса, если он был остановлен
- SIGILL - illegal instruction
- SIGSYS - bad system call
- SIGSEGV - segfault
- SIGTSTP - Ctrl+z
- SIGSTOP - предыдущей сигнал, только этот нельзя заблокировать
- SIGFPE - floating point exeption
- SIGINT - Ctrl+c
- SIGQUIT - Ctrl + \
- SIGTERM - посылается по умолчанию, если написать kill
- SIGKILL - kill -KILL
  и так далее, больше в man 7 signal
  Только 2 сигнала нельзя перехватить: **SIGKILL и SIGSTOP**
##### Какова стандартная реакция процессов на каждый из сигналов?
Есть 5 видов стандартной реакции:
- Ign - проигнорировать
- Term - убиться
- Core - убиться и сделать coredump
- Stop - остановиться
- Cont - возобновиться
##### Как вручную из терминала вызвать у стороннего процесса segfault?
```bash
kill -11 <pid>
```
##### Как из кода послать сигнал самому себе?
```c
kill(getpid(), SIGTERM) // syscall
raise(SIGTERM) // то же самое 
```
##### Как в коде программы заснуть до прихода сигнала?
```c
pause() // syscall
```
## 28.
##### Как сделать кастомный обработчик сигналов?
Можно использовать **signal** или **sigaction**
**signal** - устаревший и предоставляющй мало возможностей метод
**sigaction** - хороший и крутой.
sigaction позволяет выставить разные настройки. Например SA_NODEFER не блокирует одинаковые сигналы во время их обработки.
```c
#include <stdio.h>  
#include <signal.h>  
#include <stdlib.h>  
#include <iostream>  
  
void handler(int signum) {  
  std::cout << "signal occurred\n";  
  sleep(5);  
}  
  
int main() {  
  struct sigaction sa;  
  sa.sa_handler = &handler;  
  sigemptyset(&sa.sa_mask);  
  sa.sa_flags = SA_NODEFER;  
  
  if (sigaction(SIGINT, &sa, NULL) == -1) {  
    std::cout << "sigaction";  
    exit(1);  
  }  
  
  sleep(5);  
  
  int* ptr = NULL;  
  *ptr = 10;  
  std::cout << "after segfault";  
}
```
Замечание к коду: sleep прерывается либо сигналом, либо истечением таймера, поэтому обратно в сон не уходим после того, как отработает последний сигнал.
##### Покажите на примере, как из кода программы перехватывать segfault и делать что-то нестандартное при его наступлении.
```c++
#include <stdio.h>  
#include <iostream>  
#include <signal.h>  
  
void handler(int signum) {  
  std::cout << "caught " << signum << std::endl;
}  
  
int main() {  
  signal(SIGSEGV, &handler);  
  int* p = nullptr;  
  std::cout << *p;  
}
```
Будет бесконечно печаться caught 11, так как после того, как сигнал был обработан, мы возвращаемся на то же место программы, где получили сигнал
```c++
#include <stdio.h>  
#include <iostream>  
#include <signal.h>  

int* p = NULL;
int a = 0;

void handler(int signum) {  
  std::cout << "caught " << signum << std::endl;
  p = &a;
}  
  
int main() {  
  signal(SIGSEGV, &handler);
  std::cout << *p;  
}
// ситуация не исправится так как ассемблерные инструкции не меняются
```
##### Что происходит, если во время обработки сигнала приходит другой сигнал?
```c
#include <stdio.h>  
#include <signal.h>  
  
void handler(int signum) {  
  printf("Signal number %d received\n",#include <stdio.h>
#include <signal.h>

void handler(int signum) {
  printf("Signal number %d received\n", signum);
  sleep(5);
  printf("Signal number %d done\n", signum);
}

int main() {
  signal(SIGINT, &handler);
  signal(SIGTSTP, &handler);
  getchar();
} signum);  
  sleep(5);  
  printf("Signal number %d done\n", signum);  
}  
  
int main() {  
  signal(SIGINT, &handler);  
  signal(SIGTSTP, &handler);  
  getchar();  
}
```
- Если обрабатывали SIGINT, но пришел SIGTSTP, то начнем обрабатывать SIGTSTP
- Если послать сигнал, который уже обрабатывается, то он начнет обрабатываться после того, как предыдущий закончит. Т.е. нажали Ctrl+c, крутимся в обработчике, нажали еще раз Ctrl+c - ничего не происходит. Как выйдем из handler, начнем заново обрабатывать SIGINT (но только один раз, даже если пришло 10 сигналов SIGINT во время обработки)
- Если прилетел сегфолт при обработке сегфолта, вызовется стандартный обработчик
##### Как можно заблокировать получение других сигналов во время обработки какого-либо сигнала?
Можно использовать sigaction.
```c
sigfillset(&sa.sa_mask); // такая строчка заблокирует все приходящие сигналы
sigaddset(&sa.sa_mask, SIGUSR1); // или можно заблокировать только некоторые
sigaction(SIGINT, &sa, NULL)
```
##### Что происходит, если сигнал приходит во время выполнения какого-либо сисколла?
1. Системный вызов прервывается
   Для многих системных вызовов возвращается ошибка, и глобальная переменная `errno` устанавливается в значение `EINTR` (Interrupted System Call).
2. Системный вызов возобновляется (automatically restarted)
   Для некоторых системных вызовов можно настроить автоматическое возобновление после обработки сигнала, если установить флаг `SA_RESTART` в структуре `sigaction`.
3. Системный вызов не прерывается
   Пример: вызовы, работающие с флагом `O_NONBLOCK` (неблокирующий ввод-вывод).
## 29.
##### Что такое pipes?
>Pipes - второй вид IPC.

```c
int pipe(int pipefd[2], int flags);
```
- принимает два указателя на инт - в них записывает два файловых дескриптора, из первого можно читать, во второй - писать
- Позволяет общаться либо с собственным ребенком, либо общаться между детьми
##### Покажите в коде пример создания pipe и общения между двумя процессами с помощью pipe.
```c
#include <unistd.h>  
#include <stdio.h>  
#include <string.h>  
#include <sys/wait.h>  
#include <stdlib.h>  
  
int main(int argc, char* argv[]) {  
  char buf[1000];  
  int pipefd[2];  
  pipe(pipefd);  
  
  int cpid = fork();  
  if (cpid == 0) {  
    close(pipefd[1]);  
  
    while (read(pipefd[0], &buf, 1) > 0) {  
      write(STDOUT_FILENO, &buf, 1);  
    }  
  
    write(STDOUT_FILENO, "\n", 1);  
    close(pipefd[0]);  
    _exit(0);  
  } else {  
    close(pipefd[0]);  
    sleep(1);  
    write(pipefd[1], argv[1], strlen(argv[1]));  
    close(pipefd[1]);
    wait(NULL);  
    exit(0);  
  }  
}
```
*Объяснение:* родитель **не сразу** начинает писать в pipe, но while у ребенка не завершается, так как чтение из pipe **блокирующее**. То есть если вызван read, но читать нечего, то он закончится только если прочитает что-то, или другой конец трубы закроется. В данном случае если не закрыть pipefd\[1] в родителе, то зависнем
- если читать из пайпа, в который никто не пишет, возвращается 0
##### В какой ситуации возникает ошибка Broken pipe?
Broken pipe возникает при **записи в закрытый конец пайпа**
```c
#include <unistd.h>  
#include <string.h>  
#include <sys/wait.h>  
#include <stdlib.h>  
#include <signal.h>  
#include <iostream>  
  
void handle(int signum) {  
  std::cout << "caught " << signum << std::endl;  
}  
  
int main(int argc, char* argv[]) {  
  int pipefd[2];  
  pipe(pipefd);  
  signal(SIGPIPE, &handle);  
  int cpid = fork();  
  if (cpid == 0) {  
    close(pipefd[1]);  
    close(pipefd[0]);
    _exit(0);  
  } else {  
    close(pipefd[0]);  
    sleep(1);  
    write(pipefd[1], argv[1], strlen(argv[1]));  
    close(pipefd[1]);  
    wait(NULL);  
    exit(0);  
  }  
}
```
##### Как реализовать аналог оператора | в bash на Си?
Реализация аналога оператора `|` (пайплайна) в Bash на языке C подразумевает использование системных вызовов `pipe()`, `fork()`, `dup2()`, и `execvp()`. Оператор `|` передаёт вывод одного процесса как ввод другому, что достигается с помощью создания неименованного канала (pipe) между двумя процессами.
## 30.
##### Что такое fifo-файлы?
> FIFO - третий вид IPC.

- Представлены в виде файлов, имеющих тип p (pipe) и не хранящихся на диске
- Буфер `PIPE_BUF` имеет размер порядка нескольких килобайт. Если несчитанных данных будет больше, то программа, пытающаяся писать в fifo файл, зависает до того момента, как данные будут обработаны.
##### Как создать такой файл из терминала, а также программно?
```bash
mkfifo myfifo # в терминале
int mkfifo(const char* pathname, mode_t mode) # из кода
```
##### Что, если несколько процессов пишут в один и тот же fifo? Что, если несколько процессов читают один и тот же fifo?
###### Две программы пишут в один файл
- Если несколько процессов одновременно пишут данные в FIFO, то данные от разных процессов могут быть смешаны в произвольном порядке. Однако каждая запись будет атомарной, если её размер не превышает `PIPE_BUF` (обычно 4096 байт на современных системах Linux).
- Если размер записи превышает `PIPE_BUF`, данные могут быть частично перемешаны между процессами.
- **Пример:**
  Процесс A пишет "Hello".
  Процесс B пишет "World".
  Читатель может получить `HelloWorld` или `WorldHello`, но строки "Hello" и "World" останутся целыми, если их длина ≤ `PIPE_BUF`.
  ###### Две программы читают из одного файла
    - Когда несколько процессов читают данные из одного и того же FIFO, данные разделяются между процессами, так как FIFO работает как очередь. Каждая прочитанная часть данных удаляется из FIFO и становится недоступной для других процессов.
- **Пример:**
    - Если процесс A и процесс B читают из одного FIFO:
      Процесс A может получить первую часть данных.
      Процесс B получит следующую часть.
      Никто из них не получит полные данные одновременно.
## 31.
##### Что такое разделяемая память?
> Shared memory - четвертый вид IPC.

Есть два способа работы с разделяемой памятью - далее 1 и 2.
Первый - использование функций System five, то есть старых линуксовых, которых может не быть в других UNIX-подобных системах.
Второй - использование функций, соответствующих стандарту POSIX.
##### Какие сисколлы существуют для создания и управления разделяемой памятью?
###### 1.
```c
int shmget(key_t key, size_t size, int shmflg) // выделить память
void* shmat(int shmid, const void* shmaddr, int shmflg) // attach, присоединиться к памяти
int shmdt(const void* shmaddr) // отсоединиться
int shmctl(int shmid, int cmd, struct shmid_ds *buf); // контроль над памятью, в том числе удаление
key_t ftok(const char *pathname, int proj_id)
```
###### 2.
```c
int shm_open(const char *name, int oflag, mode_t mode); // выделить память
int shm_unlink(const char *name); // удалить

```
**ftok** - отдает ключ по пути к **существующему** файлу, один из способов не брать рандомный ключ. proj_id - ненулевое число.

##### Покажите на примере, как устроить общение через разделяемую память между двумя процессами.
###### 1.
```c
// writer
#include <stdio.h>  
#include <stdlib.h>  
#include <sys/ipc.h>  
#include <sys/shm.h>  
  
#define SHM_SIZE 1024  // Размер разделяемой памяти  
  
int main() {  
  key_t key = 1234;  // Тот же ключ, что и в writer.c  
  
  // Получение сегмента разделяемой памяти, IPC_CREAT говорит, что нужно создать память
  int shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666);  
  if (shmid < 0) {  
    perror("shmget");  
    exit(1);  
  }  
  
  // Присоединение сегмента разделяемой памяти  
  char *data = (char *)shmat(shmid, NULL, 0);  
  if (data == (char *)(-1)) {  
    perror("shmat");  
    exit(1);  
  }  
  
  // Пишем в память из потока ввода  
  fgets(data, SHM_SIZE, stdin);  
  getchar();  
  
  shmdt(data);  
  
  return 0;  
}
```

```c
// writer
#include <stdio.h>  
#include <stdlib.h>  
#include <sys/ipc.h>  
#include <sys/shm.h>  
  
#define SHM_SIZE 1024  // Размер разделяемой памяти  
  
int main() {  
  key_t key = 1234;  // Тот же ключ, что и в writer.c  
  
  // Получение сегмента разделяемой памяти
  int shmid = shmget(key, SHM_SIZE, 0666);  
  if (shmid < 0) {  
    perror("shmget");  
    exit(1);  
  }  
  
  // Присоединение сегмента разделяемой памяти  
  char *data = (char *)shmat(shmid, NULL, 0);  
  if (data == (char *)(-1)) {  
    perror("shmat");  
    exit(1);  
  }  
  
  // Чтение из разделяемой памяти  
  printf("Прочитано сообщение: %s", data);  
  
  // Отсоединение от разделяемой памяти  
  shmdt(data);  
  
  // Удаление сегмента памяти  
  shmctl(shmid, IPC_RMID, NULL);  
  
  return 0;  
}
```
*Пояснения*:
- ключ - некоторый int, однозначно идентифицирующий кусок разделяемой памяти в системе. Нужно угадать ключ, который никто не использует
- IPC_CREAT - создать новый сегмент
- запускаем writer, пишем в консоль сообщение. Запускам reader и получаем написанное сообщение. Круто!
###### 2.
```c
#include <stdio.h>  
#include <stdlib.h>  
#include <fcntl.h>  
#include <sys/mman.h>  
#include <unistd.h>  
#include <string.h>  
  
#define SHM_NAME "/shared_memory_example"  // Имя разделяемой памяти  
#define SHM_SIZE 1024                      // Размер памяти  
  
int main() {  
  // Создание объекта разделяемой памяти  
  int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);  
  if (shm_fd == -1) {  
    perror("shm_open");  
    exit(1);  
  }  
  
  // Установка размера объекта разделяемой памяти  
  if (ftruncate(shm_fd, SHM_SIZE) == -1) {  
    perror("ftruncate");  
    exit(1);  
  }  
  
  // Отображение разделяемой памяти в адресное пространство процесса  
  char* shared_memory = (char*)mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);  
  if (shared_memory == MAP_FAILED) {  
    perror("mmap");  
    exit(1);  
  }  
  
  // Запись в разделяемую память  
  fgets(shared_memory, SHM_SIZE, stdin);  
  
  // Очистка ресурсов  
  munmap(shared_memory, SHM_SIZE);  
  close(shm_fd);  

  getchar();
  return 0;  
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>

#define SHM_NAME "/shared_memory_example"  // То же имя разделяемой памяти
#define SHM_SIZE 1024                      // Размер памяти

int main() {
    // Открытие существующего объекта разделяемой памяти
    int shm_fd = shm_open(SHM_NAME, O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(1);
    }

    // Отображение разделяемой памяти в адресное пространство процесса
    char *shared_memory = mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_memory == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    // Чтение данных из разделяемой памяти
    printf("Прочитано сообщение: %s", shared_memory);

    // Очистка ресурсов
    munmap(shared_memory, SHM_SIZE);
    close(shm_fd);

    // Удаление объекта разделяемой памяти
    shm_unlink(SHM_NAME);

    return 0;
}

```
*Пояснения:*
- Вместо ключа используется имя разделяемой памяти, будет храниться в /dev/shm как виртуальный файл
##### Как посмотреть, какие участки разделяемой памяти существуют в ОС и кто их создал?
```bash
ipcs -m
strace ipcs # можно увидеть директорию, откуда ipcs берет информацию
cat /proc/sysvipc/shm
```
##### Как посмотреть, какие страницы разделяемой памяти сейчас использует данный процесс?
```bash
cd /proc/<proccess_id>/maps/
# найдем память с необычными правами. Вместо последней буквы p (private)
# стоит s (shared)
```
## 32.
##### Что такое потоки выполнения (треды, threads, нити)?
>Threads - процессы, которые разделяют общие ресурсы (кроме стека), то есть (как правило) у них совпадает виртуальное пространство
##### Покажите пример создания и использования thread на С++.
```c++
#include <thread>  
#include <iostream>  
  
void job(char c) {  
  for (int i = 0; i < 100000; ++i) {  
    std::cout << c;  
  }  
}  
  
int main() {  
  std::thread t(job, 'a'); // в этот момент запустился отдельный thread  
  job('b'); // конкурентное использование функции  
  t.join();
}
```
##### Покажите пример параллельной обработки из двух тредов каких-либо данных
```c
void job() {  
  std::vector<int> v; 
  for (int i = 0; i < 100000; ++i) {  
    v.push_back(i);  
  }  
}  
  
int main() {  
  std::thread t(job);  
  job();
  t.join();  
}
```
- Все окей, так как маллок адаптирован для многопоточного программирования
##### Что делают методы join и detach? Что происходит, если main завершается, но при этом еще не все треды завершили свою работу?
`join()` не завершает поток. Заджойненый тред ждет, пока отработает main

`detatch()` также не убивает поток. Фактически он сообщает `std::thread` что этот поток должен продолжать работать даже после уничтожения объекта `std::thread`. В деструкторе `std::thread` C++ проверяет, присоединён ли поток или отсоединён, и завершает работу программы, если проверка не пройдена.

Все треды должны быть заджойнены или задетачены (завершены) перед завершением main. Если условие не выполняется, то деструктор класса thread вызывает SIGABRT
## 33.
##### Что такое race condition?
> **Race condition (состояние гонки)** — это **ситуация, которая возникает в многозадачных или многопоточных программных системах**, когда результаты выполнения программы зависят от того, в какой последовательности выполняются инструкции или операции в различных потоках или процессах.

Состояние гонки возникает, когда несколько потоков или процессов одновременно пытаются получить доступ к одним и тем же ресурсам (например, переменным памяти, файлам или устройствам ввода-вывода) без синхронизации.

**Пример состояния гонки**: два потока пытаются изменить одну и ту же переменную. Если эти изменения не синхронизированы правильно, результаты могут быть непредсказуемыми, в зависимости от того, какой поток завершит операцию первым. 

Состояние гонки может привести к непредсказуемому поведению программы или к ошибкам в её выполнении.
##### Приведите пример, когда возникает UB из-за одновременного изменения одних и тех же данных из разных тредов.
```c
std::vector<int> v; 

void job() {  
  for (int i = 0; i < 100000; ++i) {  
    v.push_back(i);  
  }  
}  
  
int main() {  
  std::thread t(job);  
  job();
  t.join();  
}
```
Падаем. Если не упали, то открываем пиво всей общагой
##### Что такое мьютекс? Приведите пример решения проблемы race condition с помощью мьютекса.
> mutex - объект, который позволяет получить эксклюзивный доступ к какому-то участку кода. Простейший примитив синхронизации.
```c++
std::vector<int> v;  
std::mutex m;  
  
void job() {  
  m.lock();  
  // Critical section
  for (int i = 0; i < 100000; ++i) {  
    v.push_back(i);  
  }  
  m.unlock();  
}  
  
int main() {  
  std::thread t(job);  
  job();;  
  t.join();  
}
```
mutex может находиться в двух состояниях: в залоченном и в разлоченном. Пока mutex залочен, никто другой не сможет вызвать успешно lock() (треды, вызывающие lock() для залоченного mutex'а, блокируются)
##### Что такое deadlock и как он может возникнуть?
Интернет говорит, что
> **Deadlock** — это ситуация, при которой два или более потока (или процесса) блокируют друг друга, ожидая освобождения ресурса, который удерживается другим участником. В результате работа программ зацикливается, и они не могут продолжить выполнение.

Мещерин говорит, что
> Deadlock - ситуация, когда по какой-либо причине не был сделан unlock (например, вылетело исключение в критической секции). В таком случае решение - RAII над mutex. (std::lock_guard)
## 34.
##### Как реализовать std::thread, используя сисколлы?
```cpp
#include <iostream>  
#include <sys/mman.h>  
#include <sched.h>  
#include <sys/wait.h>  
  
class Thread {  
  using Callable = void(*)();  
public:  
  Thread(Callable func): func(func) {  
    stack = mmap(  
        NULL, STACK_SIZE, PROT_READ|PROT_WRITE,  
        MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0);  
    pid = clone(  
        threadRoutine, stack, CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|  
                         CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|  
                         CLONE_CHILD_CLEARTID, (void*)func);  
  }  
  
  void join() {  
    int status;  
    waitpid(pid, &status, 0);  
    pid = -1;  
  }  
  
  ~Thread() {  
    if (pid > 0) {  
      std::terminate();  
    }  
    munmap(stack, STACK_SIZE);  
  }  
private:  
  
  static int threadRoutine(void* arg) {  
    Callable routine = reinterpret_cast<Callable>(arg);  
    routine();  
    return 0;  
  }  
  
  static const int STACK_SIZE = 8392704;  
  Callable func;  
  void* stack;  
  int pid = -1;  
};  
  
void f() {  
  for (int i = 0; i < 100; ++i) {  
    std::cout << i << " ";  
  }  
  std::cout << std::endl;  
}  
  
int main() {  
  Thread t(f);  
  f();  
  t.join();  
}
```
Передача аргументов в функцию осуществляется через type erasure
Падает с сегфолтом. Почему я не знаю.
##### Как пользоваться сисколлом clone и какие у него есть параметры?
 ```c
 int clone(int (*fn)(void *), void *stack, int flags, void *arg, ... 
     /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );
```
- **fn** - что исполнять
- **stack** - указатель на стек для дочернего процесса. Обычно просто выделяется новый
- **flags** - набор флагов. Указывают что именно склонировать, определяют запустится новый процесс или тред. Выглядят как CLONE_...
- **arg** - указатель на то, что передается в вызываемую функцию в качестве аргументов
##### Покажите, как надо вызывать сисколл clone, чтобы создать полноценный std::thread
```c++
// также стек создает в виде одной страницы без каких-либо прав для защиты от угрозы перезатирания важной информации злоумышленниками
stack = mmap(NULL, STACK_SIZE, PROT_READ|PROT_WRITE,  
	        MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0);  
clone(func, stack, CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|
			CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|  
			СLONE_CHILD_CLEARTID, /*arg*/);  
// чтобы передать аргументы надо пострадать
```
##### Что из себя представляют треды с точки зрения ОС?
В Linux треды реализуются через **LWP (Lightweight Processes)**, которые представляют собой сущности ядра с почти теми же свойствами, что и процессы. Основное отличие — треды в одной группе делят ресурсы, тогда как процессы изолированы.
##### Что такое тред-группа?
> **Тред-группа** — это совокупность всех потоков, принадлежащих одному процессу в Linux. Все потоки, которые создаются процессом, образуют одну тред-группу. Главный процесс в этой группе называется **лидером тред-группы**

- Если любой из тредов в группе вызывает execve, то все треды в группе завершаются, кроме главного, и новая программа исполняется в главном треде
- Если один из тредов делает fork, то каждый тред в группе может делать wait на ребенка
##### Что такое tid, tgid, как их узнать, в чем разница с pid?
>**tgid** - общий идентификатор группы потоков, совпадает с PID основного процесса.
>**tid** - уникальный идентификатор для каждого потока.
>**pid** - идентификатор процесса. Общий для всех потоков.

Можно узнать в htop, если выставить в настройках отображение соответствующих колонок. Только htop может вместо pid показывать tid. В таком случае нужно нажать H. Но там нельзя увидеть TID, короче кринж, используем ельф!
```bash
ps -eLf # LWP отвечает за TID, TGID совпадает с PID
```
##### Как послать сигнал отдельному треду?
```bash
int tkill(int tid, int sig);
```
## 35.
##### Что такое ассемблер? Какие есть разновидности ассемблера?
> Ассемблер - язык команд процессора

Ассемблеры различаются в зависимости от архитектуры процессора и особенностей языка:
1. **По архитектуре:**
    - **x86/x86-64**: Используется для процессоров Intel и AMD. Распространённые ассемблеры — NASM, MASM, GAS.
    - **ARM**: Используется для мобильных устройств, встраиваемых систем и серверов. Ассемблер ARM имеет компактный и эффективный синтаксис.
    - и прочие
1. **По синтаксису:**
    - **Intel-синтаксис** (NASM, MASM): Более читаемый для новичков, например, в x86 используются ключевые слова `mov eax, ebx`.
    - **AT&T-синтаксис** (GAS): Используется в GNU Assembler, отличается префиксами `%` для регистров и `$` для констант (`movl %eax, %ebx`).
##### Что такое регистры? Перечислите основные регистры в архитектуре x86 и их предназначение
> Регистры - ячейки памяти в процессоре
1. rax - аккумулятор, используется для хранения результатов арифметических операций
2. rbx - base, используется для хранения адресов или данных.
3. rcx - counter, используется как счетчик в цикле.
4. rdx - data, для умножения, деления и операций с большим объемом данных.
   Со временем разрядность процессора увеличиливась: с 8 бит до 64. В связи с этим регистры менялись. Поэтому ax - имя регистра в 16-битном представлении. eax - в 32-битном, rax - в 64-битном. Причем все еще можно обращаться к ячейке разрядностью 16 или 32 бита, используя ax (младшие 16 бит) или eax
##### Расскажите про основные ассемблерные инструкции и их синтаксис: mov, арифметические инструкции, логические инструкции.
**mov**:
```c
mov    to, from
mov    [to], from // разыменовать to и положить туда from
```

**+**:
```c
int x = 4;
int y = 2;
x += y:

mov     eax, DWORD PTR [rbp-8]
add     DWORD PTR [rbp-4], eax
```

```c
long long x = 4;
int y = 2;

mov     eax, DWORD PTR [rbp-12]
cdqe   
add     QWORD PTR [rbp-8], rax
// положили значение x в eax - четырехбайтный регистр
// cdqe - "перемещаем из eax в rax". Фактически - умножение на 2
```
- перемещаем слагаемое в eax и добавляем к левому операнду
- аналогично sub (вычитание)
  **\***:
```c
int x = 4;
int y = 2;
x *= y:

mov     eax, DWORD PTR [rbp-4]
imul    eax, DWORD PTR [rbp-8]
mov     DWORD PTR [rbp-4], eax
```
- умножать можно только то, что лежит в регистре, поэтому двух команд недостаточно

**/**:
```c
int x = 4;
int y = 2;
x /= y;

mov     eax, DWORD PTR [rbp-4]
cdq
idiv    DWORD PTR [rbp-8] // делит число, лежащее в регистре a
mov     DWORD PTR [rbp-4], eax
```
- делить можно только то, что лежит в регистре
- целая часть кладется в eax, остаток - в edx
###### Умножение/деление на константы
mul и div - дорогие инструкции. Вместо них компилятор старается их заменить легковесными sub, add и операциями побитового сдвига

```c
x *= 5

mov     edx, DWORD PTR [rbp-4]
mov     eax, edx
sal     eax, 2 // побитовый сдвиг влево на 2, т.е. умножение на 4
add     eax, edx
mov     DWORD PTR [rbp-4], eax
```

```c
// деление весело преобразуется
x /= 3;

mov     eax, DWORD PTR [rbp-4]
movsx   rdx, eax // одновременно копирует и расширяет
imul    rdx, rdx, 1431655766
mov     rcx, rdx
shr     rcx, 32 // побитовый сдвиг вправо
cdq
mov     eax, ecx
sub     eax, edx
mov     DWORD PTR [rbp-4], eax
```
###### Логические инструкции
```c
and    operand1, operand2 
or     operand1, operand2
xor    operand1, operand2
not    operand
```
Результаты записываются в регистр флагов
## 36.
##### Инструкции безусловного и условного перехода в ассемблере. Регистр флагов.

```c
jmp     .L2 // безусловный переход
```

```c
if (x > 4) {
  goto mylabel;
}

cmp     DWORD PTR [rbp-4], 4
jle     .L4    // jump less equal, перепрыгиваем if
jle     .L2    // тело if'a
```
- результат сравнения записывается в регистр флагов, который состоит из 64 бит, и каждый бит отвечает за какое-либо событие
- условные переходы проверяют значения одного или нескольких флагов в регистре флагов (CF, OF, PF, SZ, ZF), которые устанавливаются в результате выполнения предыдущей команды (например cmp или test)

###### 1. **Беззнаковые переходы (unsigned)**

Используются для работы с беззнаковыми числами (например, после операций с `cmp`).

| Инструкция  | Условие                 | Флаги             | Описание                |
| ----------- | ----------------------- | ----------------- | ----------------------- |
| **je/jz**   | Равно (equal)           | ZF = 1            | Переход, если равно     |
| **jne/jnz** | Не равно (not equal)    | ZF = 0            | Переход, если не равно  |
| **jb/jnae** | Меньше (below)          | CF = 1            | Переход, если меньше    |
| **jnb/jae** | Не меньше (above/equal) | CF = 0            | Переход, если не меньше |
| **ja/jnbe** | Больше (above)          | CF = 0 и ZF = 0   | Переход, если больше    |
| **jbe/na**  | Не больше (below/equal) | CF = 1 или ZF = 1 | Переход, если не больше |

---

##### 2. **Знаковые переходы (signed)**

Используются для работы со знаковыми числами (например, после операций с `cmp`).

|Инструкция|Условие|Флаги|Описание|
|---|---|---|---|
|**jl/jnge**|Меньше (less)|SF ≠ OF|Переход, если меньше|
|**jge/jnl**|Не меньше (greater/equal)|SF = OF|Переход, если не меньше|
|**jg/jnle**|Больше (greater)|ZF = 0 и SF = OF|Переход, если больше|
|**jle/jng**|Не больше (less/equal)|ZF = 1 или SF ≠ OF|Переход, если не больше|

---

###### 3. **Переходы для конкретных флагов**

Используются для проверки отдельных флагов.

|Инструкция|Условие|Флаги|Описание|
|---|---|---|---|
|**jc**|Переход при переносе|CF = 1|CF установлен|
|**jnc**|Переход без переноса|CF = 0|CF не установлен|
|**jo**|Переполнение|OF = 1|OF установлен|
|**jno**|Без переполнения|OF = 0|OF не установлен|
|**js**|Отрицательный результат|SF = 1|SF установлен|
|**jns**|Положительный результат|SF = 0|SF не установлен|
|**jp/jpe**|Чётный результат|PF = 1|PF установлен|
|**jnp/jpo**|Нечётный результат|PF = 0|PF не установлен|

---
##### Как написать аналоги if, while и for на ассемблере?
###### if
- Если условие не выполняется, перепрыгиваем тело. Тело if'а расположено под проверкой условий
```c
if (x < y) { x = y; }
int z = 0;


mov     eax, DWORD PTR [rbp-4]
cmp     eax, DWORD PTR [rbp-8]
jge     .L2
mov     eax, DWORD PTR [rbp-8]
mov     DWORD PTR [rbp-4], eax

.L2:
mov     DWORD PTR [rbp-12], 0
```
###### for
```c
for (int i = 0; i < 100; ++i) { ++x; }

mov     DWORD PTR [rbp-8], 0 // кладем на стек i
jmp     .L2

.L3:  // тело for
add     DWORD PTR [rbp-4], 1
add     DWORD PTR [rbp-8], 1

.L2: // метка с проверкой условия
cmp     DWORD PTR [rbp-8], 99
jle     .L3
```
###### while
То же самое что и for, только без счетчика
```c
while (x < 100) { ++x; }

jmp     .L2

.L3:
add     DWORD PTR [rbp-4], 1

.L2:
cmp     DWORD PTR [rbp-4], 99
jle     .L3
```

## 37.
##### Как использовать в программе на Си ассемблерную функцию из другого файла? Покажите на примере функции проверки числа на простоту
```c
section .text  
global is_prime  
  
is_prime:  
  
  cmp  eax, 2  
  jb   .not_prime  // хз что такое jb, может можно заменить на jl
  je   .is_prime  
  
  test eax, 1  
  jz   .not_prime  
  
  mov  ecx, 3  // ecx -  счетчик в цикле
  mov  ebx, eax  
  
.check_loop:  
  mov  eax, ecx  
  mul  eax    // если у mul один аргумент, результат кладется в eax
  cmp  eax, ebx  
  jg   .is_prime  
  
  mov  edx, 0  
  mov  eax, ebx  
  div  ecx  
  cmp  edx, 0  
  je   .not_prime  

  add  ecx, 2
  jmp  .check_loop
  
.is_prime : 
  mov  eax, 1  
  ret  
  
.not_prime:  
  xor  eax, eax  
  ret
```

```cpp
#include <iostream>  
// не скомпилируется без extern "C", возможно проблема в манглировании имен
extern "C" int is_prime(int n);  
  
int main() {  
  int number;  
  
  std::cout << "Enter a number: ";  
  std::cin >> number;  
  
  int result = is_prime(number);  
  if (result) {  
    std::cout << number << " is a prime number" << std::endl;  
  } else {  
    std::cout << " is not a prime number" << std::endl;  
  }  
}
```

```bash
nasm -f elf64 is_prime.asm 
g++ is_prime.cpp is_prime.o
```
##### Как с помощью gdb делать отладку ассемблерного кода? Как просматривать текущие значения регистров, как делать пошаговое исполнение ассемблерных инструкций?
```bash
g++ -g is_prime.cpp is_prime.o
gdb ./a.out
b is_prime
disassemble # выведет ассемблерный код, который предстоит выполнять процессору
b *0x0000555555555313 # поставить брейкпоинт на инструкцию
stepi # или si, шагает по ассемблерным инструкциям
info registers # значения регистров в текущий момент
```
## 38.
##### Инструкции call и ret
> **call** - работает аналогично jump'у за исключением того, что записывает на стек адрес возврата из функции - указатель на следующую инструкцию *(rip)*
> **ret** - инструкция, обратная call. Снимает со стека адрес возврата, интерпретирует считанные байты как адрес следующей инструкции и дальше исполняет код.
##### Что такое стековый фрейм?
Стек делится на фреймы, и стековый фрейм - кусок, который соответствует локальному скопу одной функции. Каждый фрейм имеет "базу" - хранится в rbp
#### Что такое stack pointer и base pointer, регистры ebp и esp?
> **rsp** - регистр, хранящий stack pointer, показывает на верхушку стека (конец на текущий момент)
> **rbp** - регистр, хранящий base pointer, который указывает на начало базы текущего фрейма
##### Что происходит на уровне ассемблера при вызове функций и при возврате из них?
**Вызов функции**:
1. Вызывается call, который кладет на стек **адрес возврата**
2. При заходе в функцию сохраняется **предыдущий rbp** на стеке
3. в rbp записывается значение из rsp
   **Возврат из функции**:
4. rbp снимается со стека и записывается в регистр rbp
5. вызывается ret
##### Где хранятся аргументы функций при вызове? Где хранится результат функции сразу после вызова?
1. rdi - 1-ый
2. rsi - 2-й
3. rdx - 3-ый
4. rcx - 4-ый
5. r8 - **5**-ый
6. r9 - **6**-ый
   Если аргументов у функции больше, то они положаться на стек перед адресом возврата.
   Результат также по возможности кладется в регистры, но если он слишком большой, то на стек.
   ==**Вопрос в зал:** почему раньше в примере is_prime использовался rax для передачи 1-го аргумента?.. ==
   Ну если в ассемблерном коде использовать 32-битные регистры, то первый аргумент передается в eax....
##### Что делает флаг компиляции -fno-omit-frame-pointer, зачем он нужен?

	Сохранение всех начал фреймов (rbp) делает выполнимым backtrace 

Но если backtrace не нужен, можно использовать оптимизацию, позволяющую не хранить base pointer `-fomit-frame-pointer`. И наоборот с флагом `-fno-omit-frame-pointer` компилятор сохраняет использование регистра `rbp` как frame pointer.
##### Что такое атака переполнения буфера и какие средства защиты от нее существуют? Что такое stack protector, для чего он используется, что делает флаг компиляции -fno-stack-protector?
> Когда в коде осуществляется набор символов в char*, утилиты для ввода (scanf, cin) не проверяют, сколько символов было введено. Поэтому в переменную можно ввести больше символов, и адрес возврата перезатрется
> Причем если адрес возврата будет валидным, указывающим в какое-то место, то ret пойдет тупо исполнять инструкции по новому адресу

**Способы защиты:**
- fstack-protector - флаг, заставляющий компилятор сгенерировать код, который проверяет не перезатерт ли адрес возврата. По сути включает канарейки.
  Принцип работы: компилятор кладет на стек после rbp число, которое известно только ему. Перед выходом из функции смотрит не поменялось ли оно.
- NX-бит: запрещает выполнение кода в сегментах памяти, предназначенных только для данных (например, стек и куча). Защищает в ситуации, если в буфер пишем ассемблерную инструкцию, а адрес возврата ставим на начало буфера
  fno-stack-protector логично что делает.
##### Как получить ошибку “Stack smashing detected”?
```c
#include <cstdio>

void f() {
  char buf[10];
  scanf("%s", buf);
}

int main() {
  f();
}
```

```
./a.out и вводим что-то длинное
```
stack-protector - защита по умолчанию
## 40.
##### Кэши процессора. Сколько уровней кэша есть в процессоре, зачем они нужны?
> Кэш процессора (CPU cache) — это высокоскоростная память, встроенная в процессор, предназначенная для временного хранения данных и инструкций, которые часто используются. Он служит для уменьшения времени доступа к оперативной памяти (RAM), которая относительно медленная по сравнению с процессором.
> Кэш хранит копии данных из основной памяти, к которым процессор обращается наиболее часто или которые могут понадобиться в ближайшее время.

**Уровни кэшей процессора:**
- L1 - наименьший и самый быстрый тип кэшей. Находится прямо в процессоре. Одна часть хранит инструкции, вторая - данные. Размер - от 2Кб до 64Кб (в современных процах для каждого ядра)
- L2 - чуть больше и чуть медленнее L1. Может быть в процессоре, может быть снаружи. Может быть свой для каждого ядра, может быть общий (зависит от архитектуры). Размер обычно от 256Кб до 512Кб
- L3 - самый большой и самый медленный уровень. Лежит снаружи процессора и доступен всем ядрам. Играет важную роль в общении ядер и передаче данных. Размер от 1Мб до 8Мб и выше
##### Как узнать размеры кэшей своего процессора?
```bash
lscpu
```
- **L1d cache:** Кэш данных уровня 1
- **L1i cache:** Кэш инструкций уровня 1
- **L2 cache:** Кэш уровня 2.
- **L3 cache:** Кэш уровня 3.
  У меня выводит суммарный кеш, можно посмотреть для одного ядра командой
```bash
cat /sys/devices/system/cpu/cpu0/cache/index0/size # L1d для ядра 0
cat /sys/devices/system/cpu/cpu0/cache/index1/size # L1i для ядра 0
cat /sys/devices/system/cpu/cpu0/cache/index2/size # L2 для ядра 0
cat /sys/devices/system/cpu/cpu0/cache/index3/size # L3 
```
##### Что такое кэш-линия? Почему делать обход матрицы по строкам эффективнее, чем по столбцам?
> **Кэш-линия (cache line)** — это минимальная единица данных, которая может быть загружена или сохранена в кэш процессора из основной памяти (RAM). В современных процессорах от 32 до 128 байт (часто 64).

При обращении к какому-то адресу, он либо лежит в каком-то из кешей и загружается во все предыдущие, либо, если не нашли в кеше, то подгружается соответствующая кеш-линия. Поэтому обходить матрицу по столбцам быстрее - в кеш-линию выгружается непрерывный кусок памяти, а не происходят прыжки по строкам в разные куски памяти.
Из этого следует то, что взять один инт из кэша - все равно что взять 16 подряд лежащих
## 41.
##### Что такое branch prediction, в чем его идея?
Процессор пытается наперед подгрузить инструкции, но при if неизвестно, что нужно подгружать. Вычисления происходят гораздо медленее, чем загрузка следующих инструкций, так что процессор загружает ветку, которая кажется ему наиболее вероятной, наперед и обрабатывает команды (раскодирует, преобразует и тд)

Если сценарии примерно равновероятны, то процессор ошибается в половине случаев и ему приходится менять уже загруженные инструкции. Если одна ветка выполняется почти всегда, то процессор запоминает ее как более вероятную.
##### Как подсказать компилятору (средствами C++20, а также без него), какая из веток if более вероятна? Как это отразится на ассемблерном коде?
```cpp
// аттрибуты c++20
if (...) [[likely]] {}

if (...) [[unlikely]] {}

// до c++20, 1 означает, что ветка более вероятна
if (__builtin_expect(x > 0, 1)) {}
```

Компилятор может использовать эту информацию, чтобы:
1. Организовать более вероятную ветку так, чтобы она была ближе к основному потоку выполнения.
2. Уменьшить число инструкций перехода для вероятной ветки.
## 42.
##### Как делать ассемблерные вставки в коде на Си? Расскажите о синтаксисе в общих чертах
Ассемблерные вставки делаются через команду **asm()** . Обычно вместе со вставками используют ключевое слово volatile , чтобы компилятор не смог ничего соптимизировать.

Аргументы функции asm():
- Команда - сишная строка, внутри нее через % кладутся номера аргументов - переменных, которые передадутся в функцию дальше, а через $ - просто численные константы
- Далее через двоеточие переменные, куда записывать результат
- Затем через двоеточие переменные, откуда брать данные
##### Как с помощью ассемблерной вставки узнать количество тактов процессора, прошедшее между двумя данными строчками кода?
Регистр **rdtsc** сохраняет информацию о количестве тактов с момента последнего сброса процессора. При помощи ассемблерной вставки можно вычислить количество тактов, прошедших во время выполнения программы
**Плюсы** такого подхода: вызовы библиотечных функций сами по себе долгие, так что такой способ дает точный результат
## 43.
##### Что такое кольца защиты?
**Кольца защиты (Ring Protection Levels)** — это механизм управления доступом к системным ресурсам в архитектуре процессора, который используется для разграничения уровней привилегий между различными частями операционной системы и приложениями. Кольца защиты предоставляют разные уровни прав доступа к ресурсам системы, таким как память, устройства и выполнение кода, для предотвращения нежелательного или вредоносного воздействия.
- **Ring 0 (Кольцо 0) — Привилегированный режим (kernel mode):**

    - На этом уровне работает ядро операционной системы (kernel), которое имеет полный доступ ко всем системным ресурсам, включая оборудование.

- **Ring 1 (Кольцо 1) — Полупривилегированный режим:**

    - Это промежуточный уровень, который используется для драйверов и других системных приложений, которым необходим доступ к некоторым системным ресурсам, но не полный доступ как в кольце 0.

- **Ring 2 (Кольцо 2) — Полупривилегированный режим:**

    - Это также промежуточный уровень, но с ещё меньшими правами, чем у кольца 1.
    - Он редко используется в современных системах, но может быть задействован для специализированных задач и драйверов, которые требуют более ограниченного доступа.

- **Ring 3 (Кольцо 3) — Пользовательский режим (user mode):**

    - Это наименее привилегированный уровень.
    - На этом уровне выполняются обычные пользовательские приложения, которые имеют доступ только к ограниченному набору системных функций.
    - Процесс в кольце 3 не может напрямую обращаться к аппаратным ресурсам или выполнять привилегированные инструкции.
##### Какие есть режимы работы у процессора и чем они отличаются? Что такое привилегированные инструкции процессора и что к ним относится?
Режимы работы процессора:
- Привилегированный
  В этом режиме доступно больше инструкций, например:
    1. HLT - приостановить процессор
    2. INVLPG - инвалидировать запись в TLB кэше
    3. LIDT - загрузить таблицу прерываний. По ней процессор узнает, куда прыгать в случае прерывания с тем или иным сигналом
    4. MOV CR - операции надо контрольными регистрами - регистрами, доступными только в этом режиме. CR0 - хранит флаг, используется ли сейчас виртуализация памяти. CR2 - хранит адрес куда пойти при page fault.
       Также в этом режиме отключается виртуализация памяти - система ходит напрямую в адреса в памяти

- Обычный
  Тут доступны не все инструкции
  В привилегированном режиме исполняется только операционная система. Все пользователи работают в обычном режие
##### Чем принципиально отличается вызов сисколла от вызова обычной функции? Что делает ассемблерная инструкция syscall?
Syscall - особая инструкция, это настоящий сисколл. Все что использовали до этого - обертки. Не используем напрямую syscall, т.к. для нее предварительно нужно положить аргументы и еще пару вещей в правильные регистры.

Отличается она тем, что при ее исполнении процессор переключается в привилегированный режим, открывает новый стек и идет по определенному адресу выполнять сисколл. При выходе возвращает все как было.

Можно увидеть инструкцию вообще везде, если слинковать статически
```bash
g++ -static syscall.asm
objump -d a.out > output.txt
```