
##### Что такое статическая и динамическая линковка, статические и динамические либы?
**Статическая линковка** - весь необходимый код из библиотек объединяется исполняемым кодом программы в один объектный файл, т.е. копируется.
```bash
g++ -static test.cpp
```
Можно увидеть в .symtab, что адреса проставляются на последней стадии сборки программы
**Динамическая линковка** - Код библиотеки не включается в исполняемый файл, а используется во время выполнения программы
Можно увидеть в .dynsym символы, которые будут подргружены в рантайме

**Статические** библиотеки - компоновка выполняется во время компиляции, встраивая исполняемый код в двоичный файл
**Динамические** библиотеки - компоновка выполняется динамически при запуске программы
##### Как принудительно сделать статическую линковку вместо динамической и зачем это может быть нужно?
```bash 
g++ -static test.cpp
```
Может быть полезно для запуска программы на других устройствах, где могут не быть установлены нужные библиотеки.
##### Как посмотреть, от каких динамических либ зависит данный исполняемый файл?
```bash
ldd a.out
```
##### Как собрать программу с либой C++, расположенной по нестандартному адресу?
```bash
ldd a.out (увидим путь к libstdc++.so.6, если содержит например include iostream)
cd /lib/x86_64-linux-gnu/
sudo mkdir test
sudo mv libstdc++.so.6 test/
cd test/
ls -l # увидим файл, на который ведет ссылка (настоящая либа)
cd ..
sudo mv libstdc++.so.6.0.30 test/
LD_LIBRARY_PATH=/lib/x86_64-linux-gnu/test ./a.out
```
##### Как создать свою динамическую либу и собрать программу с ее использованием?
``` bash
1. g++ -shared lib.cpp -o libmyfunc.so (создание shared object)
2. подключаем header с объявлением функции
Вариант 1:
	3. sudo mv libmyfunc.so /usr/lib/
	4. g++ test.cpp -lmyfunc (порядок имеет значение)
Вариант 2:
	3. g++ test.cpp -lmyfunc -L.  (слинковать файл с либой libmyfunc.so,                которую нужно искать в текущей директории статическому линковщику (-L))
	4. LD_LIBRARY_PATH=. ./a.out
Вариант 3:
	3. g++ test.cpp -lmyfunc -L. -Wl,-rpath,/caos (динамический линковщик будет         искать либу по указанному абсолютному пути)
```
##### Для чего нужна переменная LD_LIBRARY_PATH?
Это предопределенная переменная среды в Linux / Unix, которая задает путь, к которому компоновщик должен обращаться при связывании динамических библиотек / разделяемых библиотек. Можно задавать через список путей, отделенных двоеточием, где библиотеки следует искать перед тем, как их будут искать по стандартным путям.
Полезно использовать в случае, если библиотеки расположены не по стандартному пути
##### Что такое rpath и как его использовать?
>rpath - параметр, который позволяет в бинарный файл зашить информацию о том, где нужно искать динамическую библиотеку
```bash
-Wl,-rpath,/home/liza/caos  # путь - абсолютный
#-Wl - передать на стадию линковки, через запятую перечисляется, что передать
```
##### Как посмотреть, какие вызовы библиотечных функций делает данная программа в ходе выполнения?
```bash
ltrace -p 27766 # процесс обязательно родительский
```

## 4.
###### Формат ELF
> Elf - Executable Linkable Format (файл, подлежащий либо выполнению, либо линковке). Файл ELF, как правило, является выходным файлом компилятора или линкера и имеет двоичный формат.
###### Какие 3 вида ELF-файлов существуют?
1.  REL (Relocatable file) - неслинкованный файл
2.  DYN (Shared object file) - динамическая либа
3.  EXEC (Executable file) - файл со статической линковкой
4. DYN (Position-Independent Executable file) - readelf -a a.out
5. CORE (Core file)
###### Покажите по одному примеру каждого вида
```bash
1.
g++ -c test.cpp
readelf -h test.o # REL
2.
g++ -shared test.cpp -o lib.so
readelf -h lib.so # DYN
3.
g++ -static test.cpp
readelf -h a.out # EXEC
4.
readelf -h a.out # DYN (Position-Independent Executable file)
```
###### Из каких основных секций состоят ELF-файлы?
1. Заголовок (magic в хедере - байты, с которых начинается файл. Одинаковые для всех файлво формата ELF)
2. .text - бинарный код исполняемой программы
3. .data - проинициализированные статические переменные
4. .rodata - read only data
5. .bss - непроинициализированные статические переменные
6. .symtab - таблица символов
###### Какие есть утилиты для чтения содержимого ELF-файлов?
1. hexdump - чтение по байтам
2. readelf
3. objdump (-t таблица символов)
4. nm - выводит только таблицу символов
##### Для чего нужна утилита objcopy? Приведите пример использования.
> Утилита **`objcopy`** используется для манипуляции объектными файлами в форматах, поддерживаемых GNU Binutils (например, ELF, COFF и других). Она позволяет копировать содержимое объектных файлов, изменять их формат и производить модификации секций.
```bash
objcopy --strip-debug input.elf output.elf # убрать дебажную информацию
objcopy --dump-section .text=text.bin input.elf # извлечение данных из секции .text
objcopy -O binary input.elf output.bin # конвертация файла в бинарный
```
## 5.
##### Что такое символы в терминах линковщика?
>**Символы** - сущности, которыми оперирует линковщик
##### Что такое манглирование и как (в общих чертах) оно работает?
Манглированные имена можно увидеть в таблице символов.

> Манглирование - процесс преобразования имен по специальным правилам между стадиями компиляции и линковки для дальнейшей работы линковщика

Пример работы:
\_ZSt3cin
- \_Z - символ, определенный пользователем
- St - std::
- 3 - количество символов в имени
- cin - имя
##### Как по манглированному имени восстановить исходное?
```bash
c++filt "имя"
nm -C a.out # выводит все символы с деманглированным именем
```
##### Как посмотреть список символов в данном ELF-файле?
```bash
readelf -s a.out
```
##### Что такое weak и strong символы?
Столбец **Bind** принимает значения LOCAL, GLOBAL, WEAK.
GLOBAL - объявления глобальных функций и переменных, видны из-под других translation unit'ов. (strong)
LOCAL - глобальные static функции и переменные, локальные
WEAK - GLOBAL, но если встретится такой же символ без пометки WEAK, то он перезатрется
##### Какая бывает видимость у символов, как сделать символы приватными для внешних файлов?
У символов бывает внешнее и внутреннее связывание. Символ с внешней связью виден всем единицам трансляции. С внутренней - нет.
static, примененное к глобальной функции/переменной, означает сделать ее видимой только из под данного translation unit'a.
##### Что такое релокации?
> **Релокации** — это процесс изменения адресов и указателей, которые присутствуют в исполнимом файле программы, для того чтобы программа могла быть правильно размещена в памяти при запуске.

В процессе **линковки**, линковщик должен решить, где в памяти будет размещена каждая переменная или функция. Затем линковщик должен обновить все заглушки в объектных файлах, чтобы они указывали на правильные адреса в итоговом исполнимом файле. Этот процесс и называется **релокацией**.

Пример:
Предположим, у нас есть два объектных файла — `main.o` и `foo.o`. В `main.o` есть вызов функции `foo()`, но линковщик еще не знает точный адрес этой функции, так как она находится в другом объектном файле.

1. Компилятор создает объектный файл `foo.o`, в котором функция `foo()` не имеет точного адреса, а просто метку.
2. Линковщик соединяет оба объектных файла в один исполнимый файл и решает, где в памяти будет находиться код функции `foo()`.
3. Линковщик заменяет метку на реальный адрес, например, `0x1000`, если `foo()` будет находиться по этому адресу в памяти.
4. Теперь, когда программа будет загружена в память, все вызовы функции `foo()` будут использовать этот новый адрес.

## <span style="background:rgba(163, 67, 31, 0.2)">6.</span>
##### Запуск программы. Что происходит при запуске бинаря до начала функции main, а также после ее окончания
Программа начинается со \_start, где создаются и инициализируются статические и глобальные объекты. После main уничтожаются глобальные и статические объекты. В самом конце вызывается функция exit(int), которая корректно завершает процесс.
##### Как попросить g++ не генерировать функцию \_start, а начинать программу сразу с main?
```bash
g++ -e main hello.cpp # функция _start сгенерируется, но выполнение начнется с main
```
##### Что произойдет, если запустить такую программу, и почему?
Программа упадет с сегфолтом, так как в main написан return, который делать некуда. Если же есть exit(0), но есть переменные, которые должны быть созданы и проинициализированы до main'a, то тоже сегфолт.
##### Как исправить код функции main, чтобы программа после нее корректно завершалась, если функция \_start отсутствует?
При отсутствии переменных, которые должны быть созданы и проинициализированы до входа в main, нужно написать exit(0) в конце main
## <span style="background:rgba(163, 67, 31, 0.2)">7.</span>
##### Дебаг. Что такое сборка в дебаг-режиме и в чем ее отличие от обычной?
Дебаг позволяет отследить выполнение программы
Стандартно скомпилированный файл не содержит информацию о том, какие строчки где были. Дебажная сборка добавляет отладочные символы
```bash
g++ -g test.cpp # на выходе DWARF файл
```
##### Как с помощью gdb отлаживать программу: поставить breakpoint на строчку кода или на функцию, делать шаги по строчкам (с заходом в функции и без него), выводить текущие значения переменных?
```bash
gdb -g test.cpp
gdb ./a.out
b [test.cpp:]6 # поставить breakpoint
b [test.cpp:]f # поставить breakpoint на функцию
run
n # next - шаг без захода в функцию
s # step - шаг с заходом в функцию 
p count # print - вывести текущее значение переменной
```
##### Как посмотреть backtrace от текущего места исполнения?
```
bt
```
##### Что означает фраза “core dumped” и как с помощью gdb посмотреть содержимое coredump-файла после того, как программа упала?
> core dumped означает, что сделан dump ядра, то есть прежде чем убить программу, операционная система сохраняет состояние в специальный core файл

По умолчанию на ubuntu хранятся в /var/lib/apport/coredump, но не сохраняются (лимит core файла - 0)
- ulimit -c - позволяет узнать максимальный разрешенный размер core файлов
- ulimit -c unlimited - меняет максимально разрешенный размер
  Можно:
1. читать core файл при помощи readelf
2. если собрать cpp с флагом -g, то
``` bash
gdb ./a.out path-to-core-file
# Program received signal SIGSEGV, Segmentation fault.
# 0x0000555555555327 in main () at test.cpp:6
# 6	  std::cout << v[100000000];
```
## 8.
##### Что такое системный вызов (сисколл)?
> Системный вызов - функция, которая осуществляет взаимодействие между программой и операционной системой. Предоставляется операционной системой
##### Как посмотреть в режиме реального времени, какие сисколлы происходят во время работы какой-нибудь программы?
```bash
strace -p "proccess-id"
```
##### Как посмотреть мануал для данного сисколла?
```bash
man 2 read
man 2 write
```
##### Покажите использование сисколлов на примере read и write. Как использовать возвращаемые значения этих сисколлов? Как проверить, успешно ли был выполнен сисколл, а в случае неудачи узнать, какая ошибка произошла?
```cpp
#include <unistd.h>  
#include <cstdlib>  
#include <string>  
  
int main() {  
  char buffer[100];  
  auto taken = read(0, buffer, 100);  
  if (taken == -1) {  
    auto errno_str = std::to_string(errno);  
    write(2, errno_str.data(), errno_str.size());  
    exit(1);  
  }
  if (write(1, buffer, taken) == -1) {  
    auto errno_str = std::to_string(errno);  
    write(2, errno_str.data(), errno_str.size());  
    exit(1);  
  }  
}
```
```bash
errno -l - посмотреть все возможные коды ошибок
```