##### Инструкции call и ret.

**call -- Вызов функции:**

```asm
call function           # push return_address; jmp function
call *%rax              # вызов по адресу в регистре
```

**ret -- Возврат из функции:**

```asm
ret                     # pop; jmp (возвращается на адрес, который был на стеке)
ret $16                 # pop; add $16, %rsp; jmp (очистить аргументы со стека)
```

**Механика:**

1. `call func` сохраняет адрес следующей инструкции на стек (в rbp/rsp);
2. `ret` прочитывает адрес со стека и прыгает туда.

##### Что такое стековый фрейм?

**Stack Frame (стековый фрейм)** -- это участок стека, отведённый для одного вызова функции. Содержит:

- **локальные переменные**;
- **сохранённые регистры** (callee-saved);
- **адрес возврата**;
- **аргументы функции** (по соглашению вызовов).

Пример фрейма функции на диаграмме:

```
    ┌─────────────────┐
    │ arg3            │  rsp+24 (третий аргумент, переданный на стеке)
    │ arg2            │  rsp+16
    │ arg1            │  rsp+8
    │ return_addr     │  rsp+0  (куда возвращаться)
    ├─────────────────┤ ← рsp (вершина стека при входе в функцию)
    │ saved_rbx       │  rbp-8
    │ saved_rbp       │  rbp-16
    │ local_var1      │  rbp-24
    │ local_var2      │  rbp-32
    └─────────────────┘
```

##### Что такое stack pointer и base pointer, регистры rbp и rsp?

- **rsp (Stack Pointer)** -- указывает на **вершину стека** (адрес последнего добавленного элемента). После `push`
  уменьшается, после `pop` увеличивается;
- **rbp (Base Pointer)** -- указывает на **основание текущего фрейма** (адрес сохранённого rbp предыдущей функции).
  Используется для доступа к локальным переменным и аргументам.

**Соглашение:**

- когда функция начинает работу, `[rsp]` содержит адрес возврата;
- первая инструкция обычно: `push %rbp` (сохранить старый rbp);
- затем: `movq %rsp, %rbp` (установить новый rbp = текущий rsp);
- затем: `subq $..., %rsp` (выделить место для локальных переменных).

##### Что происходит на уровне ассемблера при вызове функций и при возврате из них?

**При вызове (call):**

```asm
# ДО CALL:
rsp -> [return_address_of_caller]

call func
# CALL ДЕЛАЕТ: push return_address; jmp func

# ПОСЛЕ CALL (в начале func):
rsp -> [return_address]  # адрес, куда вернуться
```

**Функция (пролог):**

```asm
func:
    push %rbp                  # сохранить старый rbp
    movq %rsp, %rbp            # rbp = rsp
    subq $32, %rsp             # выделить 32 байта для локальных переменных
    
    # теперь:
    # rbp-8, rbp-16, ... -- локальные переменные
    # rbp+8 -- адрес возврата
    # rbp+16, rbp+24 -- аргументы (если они на стеке)
```

**Функция (эпилог/выход):**

```asm
    movq $0, %rax              # подготовить возвращаемое значение
    
    leave                      # эквивалент: movq %rbp, %rsp; pop %rbp
    # (или явно: movq %rbp, %rsp; popq %rbp)
    
    ret                        # pop адрес возврата и jmp
```

##### Где хранятся аргументы функций при вызове? Где хранится результат функции сразу после вызова?

**По System V AMD64 ABI (используется в Linux x86-64):**

**Передача аргументов:**

1. Первые 6 целочисленных/указательных аргументов -- в регистрах: `rdi, rsi, rdx, rcx, r8, r9`;
2. Остальные аргументы -- на стеке (в обратном порядке, справа налево);
3. Для float-аргументов используются xmm0-xmm7.

**Примеры:**

```c
void func(int a, int b, int c, int d, int e, int f, int g);
//         rdi  rsi  rdx  rcx  r8   r9   [rsp]
```

**Возвращаемое значение:**

- В **rax** для целых чисел и указателей;
- В **rdx:rax** для 128-битных значений (rdx -- старшие 64 бита);
- В **xmm0, xmm1** для float-значений.

**Пример:**

```c
long add(long a, long b) {
    // a = rdi, b = rsi
    return a + b;
    // результат в rax
}
```

```asm
add:
    movq %rdi, %rax         # rax = a
    addq %rsi, %rax         # rax += b
    ret                     # возврат (результат в rax)
```

##### Что делает флаг компиляции -fno-omit-frame-pointer, зачем он нужен?

**-fomit-frame-pointer** (по умолчанию при оптимизации) -- оптимизация, которая экономит:

- одну инструкцию `push %rbp` в прологе;
- одну инструкцию `movq %rbp, %rsp` в эпилоге;
- один регистр (rbp), который можно использовать для других целей.

**-fno-omit-frame-pointer** -- отключить эту оптимизацию, всегда сохранять frame pointer.

**Зачем нужен frame pointer:**

1. **Отладка (backtrace в gdb)** -- gdb использует rbp для восстановления стека вызовов;
2. **Профилирование** -- инструменты вроде `perf` используют frame pointer для трассировки;
3. **Обработка исключений** -- некоторые механизмы используют rbp.

**Пример: без frame pointer (с -fomit-frame-pointer):**

```asm
func:
    subq $32, %rsp           # только выделяем место, rbp не используем
    # ... код ...
    addq $32, %rsp           # убираем стек
    ret
```

**С -fno-omit-frame-pointer:**

```asm
func:
    push %rbp                # сохраняем frame pointer
    movq %rsp, %rbp
    subq $32, %rsp
    # ... код ...
    leave                    # восстанавливаем
    ret
```

**Использование при компилировании:**

```bash
gcc -g -fno-omit-frame-pointer -O2 prog.c -o prog    # для отладки и профилирования
gcc -O2 prog.c -o prog                                # обычная оптимизация (без frame pointer)
```

**Важно:** при использовании `-fno-omit-frame-pointer` и `-O3` можно получить хороший баланс между отладкой и
производительностью.
