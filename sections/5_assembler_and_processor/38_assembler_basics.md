##### Что такое ассемблер?

**Ассемблер (Assembly Language)** -- это низкоуровневый язык программирования, который почти 1-в-1 соответствует
машинным инструкциям процессора. Каждая команда ассемблера обычно преобразуется в одну машинную инструкцию (или
несколько).

**Отличие от машинного кода:**

- Машинный код -- это двоичные инструкции, которые непосредственно выполняет процессор;
- Ассемблер -- это мнемоническое представление машинного кода (например, `mov` вместо бинарного кода инструкции).

##### Какие есть разновидности ассемблера?

**По архитектуре процессора:**

- **x86-64** (64-битный) -- самый распространённый на десктопах и серверах;
- **x86-32** (32-битный, устаревший);
- **ARM** -- мобильные устройства, встроенные системы;
- **ARM64 (AArch64)** -- 64-битный ARM;
- **MIPS**, **PowerPC**, **RISC-V** и другие.

**По синтаксису (на примере x86-64):**

1. **Intel синтаксис:**
   ```asm
   mov rax, rbx          ; destination, source
   add rax, 5
   ```

2. **AT&T синтаксис** (GNU/Linux стандарт):
   ```asm
   movq %rbx, %rax       ; source, destination (в обратном порядке!)
   addq $5, %rax
   ```

В Linux обычно используется AT&T синтаксис (в `gas` ассемблере).

##### Что такое регистры?

**Регистры** -- это специальные высокоскоростные ячейки памяти **внутри процессора**, используемые для хранения
временных данных, адресов, флагов и т.д. Доступ к ним тысячи раз быстрее, чем к RAM.

##### Перечислите основные регистры в архитектуре x86-64 и их предназначение.

| Регистр (64-бит) | 32-бит   | 16-бит   | 8-бит    | Назначение                                                     |
|------------------|----------|----------|----------|----------------------------------------------------------------|
| **rax**          | eax      | ax       | al       | Аккумулятор (возвращаемое значение функции, умножение/деление) |
| **rbx**          | ebx      | bx       | bl       | База (обычно callee-saved)                                     |
| **rcx**          | ecx      | cx       | cl       | Счётчик (для циклов, сдвигов)                                  |
| **rdx**          | edx      | dx       | dl       | Данные (часть результата при умножении/делении)                |
| **rsi**          | esi      | si       | sil      | Индекс источника (source index), для строк                     |
| **rdi**          | edi      | di       | dil      | Индекс получателя (destination index), для строк               |
| **rsp**          | esp      | sp       | spl      | Stack pointer (вершина стека, управляется автоматически)       |
| **rbp**          | ebp      | bp       | bpl      | Base pointer (основание стека, для сохранения контекста)       |
| **r8-r15**       | r8d-r15d | r8w-r15w | r8b-r15b | Дополнительные регистры (появились в x86-64)                   |

**Соглашение о вызовах (System V AMD64 ABI):**

- **Аргументы функций** передаются в: rdi, rsi, rdx, rcx, r8, r9;
- **Возвращаемое значение** в: rax (и rdx для 128-бит результатов);
- **Callee-saved** (сохраняемые вызываемой функцией): rbx, rsp, rbp, r12-r15;
- **Caller-saved** (остальные): могут быть переписаны функцией.

##### Расскажите про основные ассемблерные инструкции и их синтаксис: mov, арифметические инструкции, логические инструкции.

**Синтаксис AT&T (используется в Linux):**

```asm
instruction source, destination    ; % для регистров, $ для чисел, размер в суффиксе
```

**MOV (перемещение):**

```asm
movq %rax, %rbx         ; 64-бит: rbx = rax
movl $42, %eax          ; 32-бит: eax = 42 (обнулит верхние 32 бита rax)
movb $0xFF, %al         ; 8-бит: al = 0xFF
movq (%rax), %rbx       ; rbx = *(unsigned long *)rax (разыменование)
movq %rax, (%rbx)       ; *(unsigned long *)rbx = rax
```

**Арифметические инструкции:**

```asm
addq %rbx, %rax         ; rax += rbx
subq $10, %rax          ; rax -= 10
imulq %rbx, %rax        ; rax *= rbx (signed)
idivq %rbx              ; rax = rdx:rax / rbx; rdx = остаток
incq %rax               ; rax++
decq %rax               ; rax--
negq %rax               ; rax = -rax
```

**Логические инструкции:**

```asm
andq %rbx, %rax         ; rax &= rbx (побитовое И)
orq %rbx, %rax          ; rax |= rbx  (побитовое ИЛИ)
xorq %rbx, %rax         ; rax ^= rbx  (побитовое XOR)
notq %rax               ; rax = ~rax  (побитовое НЕ)
shlq $3, %rax           ; rax <<= 3   (левый сдвиг)
shrq $3, %rax           ; rax >>= 3   (правый сдвиг логический)
sarq $3, %rax           ; rax >>= 3   (арифметический сдвиг, сохраняет знак)
```

**Суффиксы инструкций:**

- `b` -- byte (8 бит);
- `w` -- word (16 бит);
- `l` -- long (32 бит);
- `q` -- quad (64 бита).

Пример функции на ассемблере (сумма двух чисел):

```asm
    .globl add_numbers
    .type add_numbers, @function
add_numbers:
    # rdi = первое число, rsi = второе число
    movq %rdi, %rax     # rax = rdi
    addq %rsi, %rax     # rax += rsi
    ret                 # возврат (результат в rax)
```

Использование из C:

```c
long add_numbers(long a, long b);  // объявление

int main() {
    long result = add_numbers(5, 3);  // rdi=5, rsi=3
    // result = 8
    return 0;
}
```
