##### Что такое Instruction-Level Parallelism в процессоре?

**ILP (Instruction-Level Parallelism)** -- способность процессора **выполнять несколько инструкций параллельно** (в
одном такте), даже если они расположены последовательно в коде.

**Механизмы:**

1. **Pipeline** -- каждая инструкция разбита на этапы (fetch, decode, execute, write);
2. **Multiple execution units** -- несколько ALU, умножители, загрузчики памяти работают одновременно;
3. **Out-of-order execution** -- процессор переупорядочивает инструкции для максимальной загрузки.

**Пример:**

```c
a = b + c;    // инструкция 1
d = e * f;    // инструкция 2 (независима от 1)
g = h + i;    // инструкция 3 (независима)
```

Современный процессор может выполнить все три **параллельно** (одна в ALU, одна в multiplier, одна в load unit).

##### Покажите эксперимент, доказывающий существование этого явления.

```cpp
#include <iostream>
#include <chrono>

int main() {
    constexpr long iterations = 1'000'000'000L;
    
    using Clock = std::chrono::steady_clock;

    // ТЕСТ 1: Зависимые инструкции (нет ILP)
    auto start = Clock::now();
    
    long x = 0;
    for (long i = 0; i < iterations; ++i) {
        x = x + 1;  // зависит от предыдущего значения x
        x = x + 1;  // зависит от x, вычисленного выше
        x = x + 1;
    }
    
    auto end = Clock::now();
    auto time_dependent = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();
    
    std::cout << "Dependent:    " << time_dependent << " ns, x=" << x << "\n";

    // ТЕСТ 2: Независимые инструкции (есть ILP)
    start = Clock::now();
    
    long a = 0, b = 0, c = 0;
    for (long i = 0; i < iterations; ++i) {
        a = a + 1;  // независима от b и c
        b = b + 1;  // независима от a и c
        c = c + 1;  // независима от a и b
    }
    
    end = Clock::now();
    auto time_independent = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();
    
    std::cout << "Independent:  " << time_independent << " ns, a=" << a << ",b=" << b << ",c=" << c << "\n";
    std::cout << "Speedup: " << static_cast<double>(time_dependent) / time_independent << "x\n";
}
```

**Ожидаемый результат:**

```
Dependent:    3644583984 ns, x=3000000000
Independent:  1736035886 ns, a=1000000000,b=1000000000,c=1000000000
Speedup:      2.09937x
```

**Объяснение:** независимые инструкции выполняются параллельно, поэтому в 2-3 раза быстрее.

##### Что такое out-of-order execution в процессоре, к каким неожиданным эффектам это может приводить?

**Out-of-Order Execution** -- процессор **переупорядочивает инструкции**, чтобы максимизировать параллелизм, но
сохраняет **видимый порядок** (для программиста):

```c
a = b + c;
d = e * f;
g = h + i;
```

**Процессор может выполнить:**

1. Загрузить e, f
2. Загрузить b, c
3. Загрузить h, i
4. Вычислить d = e * f
5. Вычислить a = b + c
6. Вычислить g = h + i

**Но:** с **многопоточностью и памятью** возможны странные эффекты!

**Пример race condition:**

```c
// Поток 1
x = 1;
y = 2;

// Поток 2
if (y == 2) printf("x=%d\n", x);
```

**Без синхронизации процессор может выполнить:**

1. Поток 2: прочитать y
2. Поток 1: написать y = 2
3. Поток 2: прочитать x (будет 0, не 1!)
4. Поток 1: написать x = 1

**Вывод:** x=0 (непредсказуемо!)

**Memory barriers (`volatile`, `std::atomic`)** решают эту проблему.

##### Что такое спекулятивное исполнение кода в процессоре?

**Speculative Execution** -- процессор **предсказывает результат** условного перехода и выполняет инструкции "по
предсказанию", не дожидаясь результата:

```asm
cmp %eax, $128
je label
add %eax, %sum    # выполняется спекулятивно
label:
```

Если предсказание правильно -- бесплатное ускорение.
Если неправильно -- откат (flush pipeline).

##### Расскажите в общих чертах, к каким уязвимостям оно может приводить.

**Spectre и Meltdown** -- уязвимости, основанные на побочных эффектах спекулятивного выполнения:

**Meltdown:**

- Процессор спекулятивно выполняет инструкции до проверки доступа;
- Может прочитать привилегированную память (ядро);
- Значение загружается в кэш;
- Затем откат, но в кэше осталась информация;
- Через timing attacks можно узнать содержимое.

**Spectre:**

- Аналогично, но через branch prediction'ом;
- Можно утечь информацию из других процессов.

**Защита:**

- KPTI (Kernel Page Table Isolation) -- изолировать ядро;
- Отключение SMT (Hyper-Threading);
- Compiler barriers для критичных мест.

**Для программиста:**

- Использовать `std::atomic` для shared данных;
- Избегать timing-зависимого кода в криптографии;

