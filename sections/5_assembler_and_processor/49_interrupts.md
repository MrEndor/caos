##### Что такое прерывание, какие они бывают?

**Interrupt (Прерывание)** -- это асинхронное событие, которое заставляет процессор **переключиться на обработчик
прерывания** (interrupt handler).

**Типы прерываний:**

1. **External (Внешние) -- от аппаратуры:**
    - Сигнал от таймера (Timer interrupt);
    - Сигнал от контроллера диска;
    - Сигнал от сетевой карты;
    - Нажатие клавиши на клавиатуре.

2. **Internal (Внутренние) -- от процессора:**
    - **Exceptions (исключения):**
        - **#GP (General Protection)** -- нарушение защиты (привилегированная инструкция в user mode);
        - **#PF (Page Fault)** -- обращение к неважной странице (ошибка виртуальной памяти);
        - **#DE (Divide Error)** -- деление на 0;
        - **#BP (Breakpoint)** -- точка останова;
        - **#UD (Undefined Opcode)** -- неизвестная инструкция.

    - **Traps (ловушки):**
        - **#BP (Breakpoint)** -- INT 3;
        - **Syscall trap** -- INT 0x80 (x86-32) или syscall (x86-64).

3. **Software (Программные) -- от инструкций:**
    - `int 0x80` (системный вызов, старый способ);
    - `int 3` (breakpoint);
    - `sysenter` (быстрый syscall).

##### Что такое interrupt descriptor table?

**IDT (Interrupt Descriptor Table)** -- таблица в памяти, где хранятся описатели (дескрипторы) обработчиков прерываний.

**Структура:**

- **256 записей** (для 256 возможных прерываний/исключений);
- каждая запись содержит:
    - адрес обработчика (handler);
    - привилегии (ring level);
    - тип дескриптора (Interrupt Gate, Trap Gate и т.д.).

**Регистр IDTR:**

```asm
lidt idtr_value      # загрузить адрес IDT (привилегированная инструкция)
```

**Стандартные номера прерываний:**

| Номер | Тип       | Описание                               |
|-------|-----------|----------------------------------------|
| 0     | Trap      | Divide by zero                         |
| 1     | Trap      | Debug                                  |
| 2     | Interrupt | NMI (Non-Maskable)                     |
| 3     | Trap      | Breakpoint                             |
| 4     | Trap      | Overflow                               |
| 5     | Trap      | Bound Range Exceeded                   |
| 6     | Trap      | Invalid Opcode                         |
| 13    | Trap      | General Protection Fault               |
| 14    | Trap      | Page Fault                             |
| 32-47 | Interrupt | IRQ0-IRQ15 (таймер, диск, сеть и т.д.) |
| 128   | Trap      | Syscall (linux)                        |

##### Чем похожи и чем отличаются прерывание и вызов сисколла?

| Аспект                   | Прерывание                                      | Syscall                                |
|--------------------------|-------------------------------------------------|----------------------------------------|
| **Источник**             | Аппаратура (таймер, диск) или процессор         | Программа (инструкция syscall/int)     |
| **Асинхронность**        | Асинхронное (приходит в любой момент)           | Синхронное (контролируемое программой) |
| **Сохранение контекста** | Ядро сохраняет все регистры                     | Частичное (RCX, R11 перезаписываются)  |
| **Использование**        | Переключение контекста, обработка событий       | Доступ к услугам ядра                  |
| **Задержка**             | Непредсказуемая                                 | Предсказуемая                          |
| **Пример**               | Timer interrupt (задача переключения процессов) | read(), write(), fork()                |

##### Как сгенерировать прерывание с помощью ассемблерной вставки напрямую?

**Старый способ (x86-32, int инструкция):**

```c
#include <stdio.h>

// int 3 -- breakpoint (вызовет SIGTRAP)
void trigger_breakpoint() {
    asm volatile("int $3");  // breakpoint
}

// int 0x80 -- системный вызов (старый x86-32)
void syscall_int80(int number, int arg1) {
    asm volatile(
        "mov %0, %%eax\n\t"     # номер syscall
        "mov %1, %%ebx\n\t"     # arg1
        "int $0x80"
        : : "r"(number), "r"(arg1)
        : "eax", "ebx"
    );
}
```

**Современный способ (x86-64):**

```c
// syscall -- быстрый системный вызов
void fast_syscall() {
    asm volatile(
        "mov $1, %%rax\n\t"     # syscall 1 = write
        "mov $1, %%rdi\n\t"     # fd = stdout
        "mov %0, %%rsi\n\t"     # buffer
        "mov $5, %%rdx\n\t"     # size = 5
        "syscall"
        : : "r"("Hello")
        : "rax", "rdi", "rsi", "rdx"
    );
}
```

**Пример: вызвать segfault (SIGSEGV):**

```c
// Разыменовать нулевой указатель
void trigger_segfault() {
    asm volatile("mov $0, %%rax\n\t"
                 "mov (%%rax), %%rbx"
                 : : : "rax", "rbx");
}
// SIGSEGV -> Page Fault (#PF) исключение
```

##### Как ОС с помощью механизма прерываний держит под контролем все процессы?

**Timer Interrupt (наиболее важный):**

1. **Таймер срабатывает** каждые ~10ms (обычно 100Hz);
2. **Генерируется IRQ0** (timer interrupt);
3. **Процессор прерывает текущий процесс** и вызывает обработчик из IDT;
4. **Ядро спасает контекст** (сохраняет все регистры в kernel stack);
5. **Вызывается scheduler** -- выбирает следующий процесс;
6. **Восстанавливает контекст** следующего процесса;
7. **Возвращает управление** (ret из обработчика).

**Результат:** процессы кажутся выполняющимися параллельно (time slicing).

**Код функции scheduler (упрощённо):**

```c
void timer_interrupt_handler() {
    // Сохранен контекст текущего процесса
    
    // Выбрать следующий процесс для выполнения
    struct task_struct *next = pick_next_task();
    
    // Переключить на новый процесс
    context_switch(current, next);
    
    // Вернуться (CPU продолжит выполнение нового процесса)
}
```

**Диаграмма переключения контекста:**

```
Процесс A выполняется
     ↓
Timer interrupt (через 10ms)
     ↓
IDT[32] → timer_handler()
     ↓
Сохранён контекст A в kernel
     ↓
Выбран процесс B
     ↓
Восстановлен контекст B
     ↓
RET из обработчика
     ↓
Процесс B продолжает (откуда остановился)
```

**Другие важные прерывания:**

- **Page Fault (#PF)** -- обращение к невалидной странице; ядро загружает нужную страницу из диска;
- **Keyboard interrupt** -- нажатие клавиши, попадает в буфер;
- **Network interrupt** -- пакет прибыл, добавляется в очередь;
- **I/O interrupt** -- диск завершил операцию чтения.

**Вывод:** прерывания -- это механизм, который позволяет ОС **отбирать контроль** от процессов и **переключаться между
ними**, обеспечивая многозадачность.
