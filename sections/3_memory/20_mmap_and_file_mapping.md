##### Можно ли запросить конкретный виртуальный адрес для выделения памяти?

У `mmap` есть параметр `addr` и флаг `MAP_FIXED`:

```c
void *ptr = mmap((void*)0x60000000, 4096,
                 PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
                 -1, 0);
```

- без `MAP_FIXED` это всего лишь «подсказка» ядру, оно может выбрать другой адрес;
- с `MAP_FIXED` ядро **обязано** использовать указанный диапазон (может при этом перезатереть существующее
  отображение) — поэтому применять его нужно с большой осторожностью.

##### Почему при обращении за границу массива segfault происходит не всегда?

Память выделяется страницами (обычно 4 КБ). Если массив лежит, например, в середине страницы, то небольшое выход за его
пределы всё ещё попадает в **ту же страницу**, которая помечена как доступная. Ядро не знает о логических границах
массива — только о границах страниц.

Segfault будет только когда обращение попадёт в:

- неотображённую страницу;
- или страницу без нужных прав.

Поэтому выход за границы массива — это **UB на уровне языка**, но не обязательно моментальный `SIGSEGV`.

##### Покажите пример использования mremap.

mremap -- изменение размера отображения:

```c
#include <sys/mman.h>

void *mremap(void *old_address, size_t old_size,
             size_t new_size, int flags /*, ... */);
```

Пример увеличения анонимного `mmap` с 4 КБ до 8 КБ:

```c
void *ptr = mmap(NULL, 4096,
                 PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS,
                 -1, 0);

ptr = mremap(ptr, 4096, 8192, MREMAP_MAYMOVE);
if (ptr == MAP_FAILED) {
    perror("mremap");
}
```

`MREMAP_MAYMOVE` разрешает ядру переместить область на новый адрес, если рядом не хватает места.

##### Как с помощью mmap загрузить файл в оперативную память? Можно ли таким образом поменять файл?

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd = open("example.txt", O_RDWR);
    struct stat st;
    fstat(fd, &st);

    char *data = mmap(NULL, st.st_size,
                      PROT_READ | PROT_WRITE,
                      MAP_SHARED,
                      fd, 0);
    if (data == MAP_FAILED) {
        perror("mmap");
        return 1;
    }

    data[0] = 'X';      // меняем первый байт файла

    msync(data, st.st_size, MS_SYNC); // принудительно записать изменения

    munmap(data, st.st_size);
    close(fd);
}
```

##### В чем разница между MAP_SHARED и MAP_PRIVATE? Зачем нужен сисколл msync?

- `MAP_SHARED`:
    - изменения в памяти **видны другим процессам**, которые отобразили тот же файл с `MAP_SHARED`;
    - изменения (при определённых условиях + `msync`/`munmap`) записываются обратно в файл.

- `MAP_PRIVATE`:
    - используется режим copy‑on‑write: изначально страница общая, но при записи создаётся приватная копия;
    - изменения **не попадают** в исходный файл и не видны другим процессам.

```c
int msync(void *addr, size_t length, int flags);
```

`msync` обеспечивает сброс изменений из страничного кеша в файл на диске для отображённого участка. Без него ядро рано
или поздно само сбросит данные, но **момент не гарантирован**. Для надёжной записи (например, журнал БД) используют
`msync`/`fsync`.
