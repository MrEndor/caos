##### На какие секции делится адресное пространство процесса?

**Типичное адресное пространство процесса (Linux, ELF):**

Если посмотреть `/proc/<pid>/maps`, можно увидеть примерно такое:

- сегмент кода (`.text`) — обычно только чтение + исполнение (r-x);
- сегменты данных:
    - `.rodata` — только чтение (r--);
    - `.data` — инициализированные глобальные/статические переменные (rw-);
    - `.bss` — неинициализированные глобальные/статические переменные (логически есть, физически занимают место только в
      памяти, а не в файле);
- heap (куча) — зона, из которой `malloc` выдаёт память;
- стеки потоков (stack) — вверху адресного пространства;
- участки, отображённые через `mmap` (под библиотеки `.so`, файлы, анонимную память и т.д.).

##### В чем разница между секциями .data, .rodata и .bss?

- `.data` — проинициализированные глобальные/статические переменные **с ненулевым** значением:
  ```c
  int x = 5;      // .data
  ```
- `.rodata` — константы и строковые литералы (read‑only):
  ```c
  const char *s = "hello";   // сама строка в .rodata
  ```
- `.bss` — глобальные/статические переменные, инициализированные нулём или неинициализированные явно:
  ```c
  int y;         // .bss
  int z = 0;     // тоже .bss
  ```

В файле ELF для `.bss` не хранятся реальные нули — только информация «нужно выделить такой‑то участок и обнулить». Это
экономит место.

##### Зачем нужны сисколлы brk и sbrk?

Исторически кучу можно было расширять через системные вызовы:

```c
#include <unistd.h>

int brk(void *addr);          // установить новый program break
void *sbrk(intptr_t inc);     // сдвинуть program break на inc
```

`program break` — граница кучи. Сейчас напрямую вызывать `brk`/`sbrk` в пользовательском коде не рекомендуется; `malloc`
сам иногда использует `brk` (для небольших аллокаций), а иногда `mmap`.

##### Покажите использование сисколлов mmap и munmap базовом сценарии.

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t length,
           int prot, int flags,
           int fd, off_t offset);
int munmap(void *addr, size_t length);
```

Пример анонимного отображения (просто выделение памяти):

```c
#include <sys/mman.h>
#include <stdio.h>

int main() {
    void *ptr = mmap(NULL, 4096,
                     PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS,
                     -1, 0);
    if (ptr == MAP_FAILED) {
        perror("mmap");
        return 1;
    }

    // можно использовать ptr как обычный массив байт
    ((char *)ptr)[0] = 'A';

    munmap(ptr, 4096);
    return 0;
}
```

`MAP_ANONYMOUS` означает, что память не привязана к файлу, а выделяется просто как странички RAM/подкачки.

##### Как посмотреть, как выглядит в данный момент адресное пространство процесса?

**Как посмотреть текущее адресное пространство процесса:**

- изнутри программы:

```bash
cat /proc/$$/maps
```

- для любого процесса по PID:

```bash
cat /proc/<pid>/maps
pmap <pid>
```

Там видно диапазоны адресов, права (rwx), тип (anon, stack, heap, библиотека) и соответствующие файлы.
