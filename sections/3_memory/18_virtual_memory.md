##### Что такое виртуальная память? Зачем она нужна и какие у неё преимущества?

**Виртуальная память** — это абстракция, предоставляемая ОС, которая позволяет процессам работать с памятью как с 
**непрерывным адресным пространством**, независимо от того, где эти данные на самом деле расположены в физической
памяти (RAM) или на диске.

Когда программа обращается к памяти через указатель (виртуальный адрес), она не обращается к RAM напрямую. Вместо этого
ОС и аппаратное обеспечение преобразуют виртуальный адрес в физический адрес.

**Как это работает:**

- Программа оперирует **виртуальными адресами** (например, `0x7fffffff5000`)
- ОС через **MMU (Memory Management Unit)** преобразует их в физические адреса RAM
- Данные могут находиться в разных местах: в RAM, на диске (swap), в файлах

**Преимущества виртуальной памяти:**

1. **Изоляция процессов** — каждый процесс имеет свой виртуальный адресный простор, защищены друг от друга

2. **Удобство программирования** — каждый процесс думает, что у него есть память с адреса 0x0

3. **Непрерывное адресное пространство** — можно запросить массив из 100'000 элементов, а физически он может быть
   разбросан. Виртуально всё выглядит непрерывно

4. **Эффективное использование памяти** — ОС может:
    - Выгружать неиспользуемые страницы на диск (swap)
    - Загружать страницы по требованию (lazy loading)
    - Делиться одной физической страницей между несколькими процессами
    - Использовать больше памяти, чем есть физически

5. **Отображение файлов в память** — можно маппить файлы в память через `mmap()`, ускоряя работу

6. **Разделение памяти** — динамические библиотеки загружаются один раз и разделяются между процессами

7. **Защита памяти** — разные права доступа на разные области (.text read-only, .data read-write)

8. **ASLR (Address Space Layout Randomization)** — адреса рандомизируются для защиты от атак

**Типичное расположение в памяти процесса:**

```
Высокие адреса (0xffff...)
    ┌─────────────────────────────┐
    │   Kernel Space (ядро)       │  недоступно для user процессов
    ├─────────────────────────────┤
    │   Stack (стек)              │  растёт вниз ↓
    │   (локальные переменные,    │  (от высоких к низким адресам)
    │    параметры функций)       │
    ├─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┤
    │                             │
    │   Gap (свободное место)     │  этот gap растёт при необходимости
    │                             │
    ├─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─┤
    │   Heap (куча)               │  растёт вверх ↑
    │   (malloc, new,             │  (от низких к высоким адресам)
    │    динамическая память)     │
    ├─────────────────────────────┤
    │  .bss (неинициализированное │
    │   глобальные переменные)    │
    ├─────────────────────────────┤
    │  .data (инициализированные  │
    │   глобальные данные)        │
    ├─────────────────────────────┤
    │   .rodata (константы)       │
    ├─────────────────────────────┤
    │   .text (код программы)     │  read-only, executable
    ├─────────────────────────────┤
    │   ELF header, segments      │
Низкие адреса (0x00000...)
```

---

##### Что такое `maps` — карта памяти процесса? Какие сегменты там обычно есть?

**`maps`** — это файл в `/proc/{PID}/maps`, который показывает **карту виртуального адресного пространства** процесса,
отображение виртуальных адресов на физические.

**Как посмотреть:**

```bash
# Для текущего процесса
cat /proc/self/maps

# Для конкретного процесса
cat /proc/1234/maps
```

**Пример содержимого `/proc/self/maps`:**

```
Address           Perms Offset  Dev     Inode           Name
55c3d3000000-55c3d302f000 r--p 00000000 08:10 123456 /usr/bin/a.out
55c3d302f000-55c3d304d000 r-xp 0002f000 08:10 123456 /usr/bin/a.out
55c3d304d000-55c3d3056000 r--p 0004d000 08:10 123456 /usr/bin/a.out
55c3d3057000-55c3d305a000 rw-p 00056000 08:10 123456 /usr/bin/a.out
55c3d305a000-55c3d307b000 rw-p 00000000 00:00 0      [heap]
7fe04e000000-7fe04e21b000 r-xp 00000000 08:10 234567 /lib/x86_64-linux-gnu/libc-2.31.so
7fe04e21b000-7fe04e3ab000 ---p 0021b000 08:10 234567 /lib/x86_64-linux-gnu/libc-2.31.so
7fe04e3ab000-7fe04e3af000 r--p 0021b000 08:10 234567 /lib/x86_64-linux-gnu/libc-2.31.so
7fe04e3af000-7fe04e3b1000 rw-p 0021f000 08:10 234567 /lib/x86_64-linux-gnu/libc-2.31.so
7fff0e5dd000-7fff0e5fe000 rw-p 00000000 00:00 0      [stack]
7fff0e5fe000-7fff0e601000 r--p 00000000 00:00 0      [vvar]
7fff0e601000-7fff0e603000 r-xp 00000000 00:00 0      [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
```

**Структура строки:**

```
ADDRESS           PERMS OFFSET  DEV     INODE           PATHNAME
start-end         r/w/x offset  major:minor number      file/region

PERMS (права доступа):
- r = read (чтение)
- w = write (запись)
- x = execute (выполнение)
- p = private (приватная копия, Copy-on-Write)
- s = shared (разделяемая, видна другим процессам)
```

**Основные сегменты в карте памяти:**

| Сегмент                     | Содержимое                      | Права | Описание                                                     |
|-----------------------------|---------------------------------|-------|--------------------------------------------------------------|
| **.text**                   | Машинный код                    | r-x   | Чтение и выполнение. Может быть разделён между процессами    |
| **.rodata**                 | Константы, строки               | r--   | Read-only: `"Hello"`, константы, таблицы виртуальных методов |
| **.data**                   | Инициализированные переменные   | rw-   | Глобальные переменные с начальными значениями                |
| **.bss**                    | Неинициализированные переменные | rw-   | Занимает 0 байт в файле, полный размер в памяти. Нулевые     |
| **[heap]**                  | Динамическая память             | rw-   | malloc, new, mmap. Растёт вверх                              |
| **[stack]**                 | Стек программы                  | rw-   | Локальные переменные, параметры функций. Растёт вниз         |
| **[vdso]**                  | Virtual Dynamic Shared Object   | r-x   | Код ядра, отображённый в user space для ускорения syscall    |
| **[vvar]**                  | Variables for vdso              | r--   | Переменные для vdso                                          |
| **[vsyscall]**              | Virtual System Call             | r-x   | Древний механизм (заменён на vdso)                           |
| **Динамические библиотеки** | Код libc.so, libm.so и т.д.     | r-x   | Разделяемые объекты                                          |

**Пример: посмотреть информацию текущего процесса:**

```cpp
#include <iostream>

int main() {
    getchar();  // Останавливаемся, чтобы посмотреть maps
    return 0;
}
```

```bash
g++ -o prog prog.cpp
./prog &
PID=$!
cat /proc/$PID/maps
```

**Границы адресов на x86-64:**

- На x86-64 с 48-битной адресацией:
    - **Kernel space**: `0xffff800000000000 - 0xffffffffffffffff` (верхняя половина)
    - **User space**: `0x0 - 0x7fffffffffffffff` (нижняя половина)
    - Обычно код ОС в верхних адресах, приложения в нижних

---

##### Что такое страничная организация памяти? Как устроены таблицы страниц и где они хранятся?

**Страничная организация памяти** — это разделение памяти на **фиксированные блоки (страницы)**, обычно по **4 KB** на
x86-64.

**Почему страницы:**

- Проще управлять памятью малыми блоками
- Упрощает защиту и разделение памяти между процессами
- Позволяет отображать виртуальные адреса на физические динамически

**Таблицы страниц (Page Tables)** — это структура данных, которая отображает виртуальные адреса на физические:

```
Виртуальный адрес: 0x12345678
    ↓ (разбор)
    Номер страницы:      0x12345 (индекс в таблице)
    Смещение в странице: 0x678    (смещение внутри страницы 0-4095)
    ↓ (поиск в page table)
    Физический адрес: 0xAABBB678 (физический адрес)
```

**Структура таблиц страниц на x86-64 (4-уровневая иерархия):**

```
Виртуальный адрес: 0x12345678

Биты 47-39: индекс в PML4 (4096 записей)
Биты 38-30: индекс в PDPT (4096 записей)
Биты 29-21: индекс в PD   (4096 записей)
Биты 20-12: индекс в PT   (4096 записей)
Биты 11-0:  смещение в странице (4096 байт = 4 КБ)

Процесс:
PML4[бит 47-39] → PDPT → PD → PT → физический адрес
```

**Где хранятся таблицы страниц:**

- **В оперативной памяти** — для быстрого доступа
- **Каждый процесс имеет свой набор таблиц** — указатель на корневую таблицу хранится в регистре **CR3**
- **При переключении контекста** процессор переключает CR3 на таблицу нового процесса
- **Иерархическая структура** — не все уровни выделяются сразу (по требованию)

**Размер таблиц страниц:**

- На одном уровне: 512 записей × 8 байт = 4 КБ
- На один процесс: обычно 4 уровня, но выделяется по требованию (~100-500 МБ при полной загрузке)

**Структура записи в таблице страниц (PTE — Page Table Entry):**

```
PTE: 64-bit значение

[51:12] Physical Page Frame Number (40 бит) — физический адрес страницы
[6]     D - Dirty (страница была изменена)
[5]     A - Accessed (страница была доступна)
[2]     U/S - User/Supervisor (0=kernel, 1=user)
[1]     W/R - Read/Write (0=read-only, 1=read-write)
[0]     P - Present (1=в памяти, 0=на диске/отсутствует)
```

**Просмотр таблиц страниц процесса:**

```bash
# Просмотр информации о памяти процесса
cat /proc/<pid>/maps

# Более подробная статистика
cat /proc/<pid>/status | grep -E "VmPeak|VmSize|VmRSS"
# VmPeak: пиковое использование виртуальной памяти
# VmSize: текущий размер виртуальной памяти  
# VmRSS: количество страниц в оперативной памяти (resident set)
```

---

##### Что такое MMU, TLB? Как устроена трансляция виртуальных адресов в физические?

**MMU (Memory Management Unit)** — это аппаратный модуль в процессоре, который преобразует виртуальные адреса в
физические.

**TLB (Translation Lookaside Buffer)** — это аппаратный кэш внутри процессора для ускорения преобразования адресов. Без
TLB каждый доступ к памяти требовал бы нескольких обращений к таблице страниц в RAM, что очень медленно.

**Процесс трансляции адреса:**

```
1. CPU выдаёт виртуальный адрес (например, 0x7fffffff5a2c)

2. Проверка TLB (аппаратный кэш)
   ├─ TLB Hit (попадание): найдено!
   │  └─ Вернуть физический адрес → быстро (~4 наносекунды, 99% случаев)
   └─ TLB Miss (промах): не найдено
      └─ Продолжить дальше

3. Полный поиск через Page Walk (обход таблиц страниц в RAM)
   - На x86-64 используется 4-уровневая иерархия
   - PML4 → PDPT → PD → PT → физический адрес
   - На каждом уровне берётся часть адреса как индекс
   - ~200 наносекунд (4 обращения к памяти + IO)

4. Если страница отсутствует или нарушены права
   └─ Page Fault исключение → обработка ядром

5. Если всё ОК
   └─ Добавить запись в TLB (вытеснив старую при необходимости)
```

**Раздельные TLB для инструкций и данных:**

- **iTLB (Instruction TLB)** — для кода (fetch stage конвейера)
- **dTLB (Data TLB)** — для данных (load/store stage)

Раздельность даёт:

- Параллелизм: одновременно fetch + execute без конфликтов
- Изоляцию: ошибка в dTLB не повредит iTLB

**Пример: векторы vs списки — влияние на TLB:**

```cpp
#include <vector>
#include <list>

int main() {
    // Тест 1: вектор (contiguous memory)
    std::vector<int> vec(100'000);
    for (int i = 0; i < 100'000; ++i) {
        vec[i]++;  // Sequential access → хорошая пространственная локальность
    }
    // Большинство обращений попадают на одну страницу → TLB-hit
 
    // Тест 2: список (разбросанная память)
    std::list<int> lst(100'000);
    for (auto& elem : lst) {
        elem++;  // Random access в памяти → плохая локальность
    }
    // Много TLB-miss'ов, много page faults
 
    return 0;
}
```

**Контекстное переключение и TLB:**

```
Процесс A работает (адреса в TLB относятся к А)
                ↓
Переключение на Процесс B
                ↓
Все старые записи TLB устаревают (не относятся к B)
                ↓
Нужно очистить TLB (TLB flush) или использовать ASID
                ↓
Первые обращения B — все TLB-miss'ы
```

В современных системах используется **ASID (Address Space ID)** в TLB, чтобы не очищать его при переключении контекста.

**Просмотр статистики TLB:**

```bash
# Просмотр TLB статистики
sudo perf stat -e dTLB-loads,dTLB-load-misses,iTLB-loads,iTLB-load-misses ./program

# Output:
#  123,456  dTLB-loads           (data TLB hits)
#    1,234  dTLB-load-misses     (data TLB misses = 1%)
#   234,567  iTLB-loads          (instruction TLB hits)
#      789  iTLB-load-misses     (instruction TLB misses)
```

---

##### Что такое Page Fault? Какие бывают Page Fault'ы? Major и Minor page faults?

**Page Fault** — это исключение, возникающее при обращении к виртуальной странице памяти, которая:

- Не отображена на физическую память (но разрешена)
- Запрещена для данного типа доступа (например, попытка записи в read-only страницу)

При Page Fault'е сигнал отправляется CPU, и управление передаётся обработчику исключений в ядре ОС.

**Типы Page Fault'ов:**

1. **Minor Page Fault** (мягкая ошибка) — страница уже в ОЗУ, но процесс о ней «не знает»
    - ОС просто обновляет таблицы страниц для этого процесса
    - Без дисковых операций
    - Очень быстро (~микросекунды)
    - Частый случай при копировании (COW) и fork()

2. **Major Page Fault** (жёсткая ошибка) — страница должна быть загружена с диска
    - Обращение к файлу на диске
    - Swap-файл (если физической памяти недостаточно)
    - Отображённые файлы через mmap()
    - Очень медленно (~миллисекунды, т.е. в миллион раз медленнее)

3. **Segmentation Fault (SIGSEGV)** — попытка доступа к запрещённой странице
    - Обращение к NULL
    - Нарушение прав (чтение из области без r, запись без w, выполнение без x)
    - Обращение в kernel space из user space

**Примеры Page Fault'ов:**

```cpp
// Minor fault: первое обращение к выделенной памяти
int *arr = new int[1000];
arr[0] = 5;  // ← Minor fault (если страница не была зафиксирована)

// Major fault: доступ к не загруженной странице из файла
void *mapped = mmap(fd, 4096, PROT_READ, MAP_SHARED, fd, 0);
int value = *(int*)mapped;  // ← Major fault (загружает с диска)

// Major fault: доступ к swap области
malloc(1000000000);  // Выделяем гигабайт
// При работе с этой памятью произойдут major faults

// Segmentation Fault: обращение в нулевую страницу
int *ptr = nullptr;
*ptr = 10;  // ← SIGSEGV (нулевая страница не отображена)
```

**Обработка Page Fault'а в ядре:**

```
1. CPU возникает исключение (INT 14 на x86)
   ↓
2. ОС получает управление
   ↓
3. ОС проверяет, является ли адрес законным
   ├─ Нет → SIGSEGV → процесс убивается
   └─ Да → продолжить
   ↓
4. ОС ищет нужную страницу
   ├─ В памяти → Minor fault → обновить page table
   └─ На диске → Major fault → загрузить с диска
   ↓
5. Если нужна загрузка с диска
   ├─ Найти физическую страницу (может вытеснить другую)
   ├─ Инициировать IO операцию (диск медленный!)
   ├─ Процесс уходит в sleep (yields CPU)
   └─ Другой процесс может выполняться
   ↓
6. IO завершена, страница в памяти
   ↓
7. ОС обновляет page table этого процесса
   ↓
8. Процесс пробуждается, повторяет инструкцию
```

**Copy-on-Write (CoW) и Minor Faults:**

```cpp
#include <unistd.h>

int main() {
    int *data = new int[1000];
    data[0] = 42;
 
    int pid = fork();
 
    if (pid == 0) {
        // Child: читаем из наследованной памяти
        int val = data[0];  // ← Minor fault (страница в памяти, обновляем page table)

        // Меняем значение
        data[0] = 100;  // ← Minor fault? Нет! COW!
        //   ОС создаёт копию страницы для child'а
        //   Parent видит 42, child видит 100
    }
 
    return 0;
}
```

COW оптимизирует fork(), не копируя память физически до первой записи.

**Просмотр статистики Page Fault'ов:**

```bash
# Посмотреть page faults процесса
ps aux
# Fields: ... MINFLT MAJFLT ...

# Более подробно
/usr/bin/time -v ./program | grep -E "page|fault"
# Output:
# Major (requiring I/O) page faults: 150
# Minor (reclaiming a frame) page faults: 500000
```

---

##### Какие системные вызовы используются для работы с виртуальной памятью?

**mmap** — отображение файлов или памяти в адресное пространство процесса

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
```

**Примеры:**

```cpp
// Выделить анонимную память (не привязана к файлу)
char *ptr = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, 
                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
strcpy(ptr, "Hello!");
munmap(ptr, 4096);

// MAP_SHARED vs MAP_PRIVATE
char *shared = mmap(NULL, 4096, PROT_WRITE, MAP_SHARED, fd, 0);
shared[0] = 'X';  // Видна другим процессам, пишется в файл

char *private = mmap(NULL, 4096, PROT_WRITE, MAP_PRIVATE, fd, 0);
private[0] = 'X';  // Copy-on-Write, не видна другим
```

**mprotect** — изменить права доступа на выделенную память

```c
#include <sys/mman.h>

int mprotect(void *addr, size_t length, int prot);
```

```cpp
char *buffer = (char *)malloc(4096);
mprotect(buffer, 4096, PROT_READ);  // Запретить запись
mprotect(buffer, 4096, PROT_READ | PROT_WRITE);  // Разрешить
```

**brk / sbrk** — изменить конец heap'а (program break)

```c
#include <unistd.h>

int brk(void *addr);
void *sbrk(intptr_t increment);
```

```cpp
void *current_break = sbrk(0);      // Получить текущий break
char *data = (char *)malloc(1000);  // Использует brk или mmap
void *new_break = sbrk(0);          // Новый break
```

**Примечание:** Современный malloc часто использует `mmap()` для больших выделений (обычно > 128 КБ) вместо `brk()`.

**mremap** — расширить/сжать ранее выделенную память

```c
#include <sys/mman.h>

void *mremap(void *old_address, size_t old_size, size_t new_size, int flags);

void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
ptr = mremap(ptr, 4096, 8192, MREMAP_MAYMOVE);  // Расширить до 8 КБ
```

**Просмотр виртуальной памяти процесса:**

```bash
# Текущий процесс
cat /proc/self/maps

# Конкретного процесса
cat /proc/1234/maps

# Детали об использовании памяти
cat /proc/self/status | grep -E "VmPeak|VmHWM|VmRSS"
# VmPeak:  пиковое использование виртуальной памяти
# VmHWM:   пиковое использование физической памяти (RSS)
# VmRSS:   текущее использование физической памяти
```
