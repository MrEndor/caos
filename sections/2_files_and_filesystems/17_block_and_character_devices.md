##### Блочные и символьные устройства. В чем разница? Приведите примеры того и другого.

**Символьные (character) vs блочные (block) устройства:**

- **Символьное устройство (`c`)**:
    - работает как поток байт (последовательный ввод‑вывод);
    - обычно не поддерживает произвольное позиционирование (`lseek`);
    - примеры: `/dev/tty`, `/dev/null`, `/dev/random`, `/dev/urandom`.

- **Блочное устройство (`b`)**:
    - обеспечивает доступ к данным фиксированными блоками;
    - поддерживает случайный доступ по смещению;
    - используется файловыми системами;
    - примеры: `/dev/sda`, `/dev/sda1`, `/dev/nvme0n1`.

Проверить тип можно через:

```bash
ls -l /dev/sda
ls -l /dev/tty
```

в первом столбце будет `b` или `c`.

##### Как прочитать данные с какого-нибудь символьного устройства, а также отправить данные на устройство?

С точки зрения программы это обычные файлы:

```c
#include <fcntl.h>
#include <unistd.h>

// чтение случайных байт
int fd = open("/dev/random", O_RDONLY);
unsigned char buf[32];
ssize_t n = read(fd, buf, sizeof(buf));
close(fd);

// запись в терминал
int tty = open("/dev/tty", O_WRONLY);
write(tty, "Hello\n", 6);
close(tty);
```

##### Что такое виртуальные устройства, что такое /dev/null, /dev/random, /dev/zero?

В Linux виртуальные устройства — это абстракции, которые представляют собой логические устройства, не связанные напрямую
с физическим оборудованием.

- `/dev/null` — "чёрная дыра":
    - чтение всегда даёт EOF;
    - запись всегда успешно «проглатывает» данные, ничего не сохраняя;
- `/dev/zero` — бесконечный поток нулевых байт:
  ```bash
  dd if=/dev/zero of=file bs=1M count=10
  ```
- `/dev/random`, `/dev/urandom` — генераторы случайных чисел.

Эти "файлы" не занимают места на диске: это интерфейс к драйверам/ядру.

##### Как сделать, чтобы приложение направило свой stdout / stderr на определенный терминал?

Допустим, есть псевдотерминал `/dev/pts/1`. В C:

```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd = open("/dev/pts/3", O_WRONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    dup2(fd, 1);      // перенаправить stdout
    // dup2(fd, 2);   // при желании — и stderr

    close(fd);

    printf("Hello from process!\n");
}
```

В shell то же самое:

```bash
./prog > /dev/pts/3 2>&1
```

##### Где в файловой системе хранится информация о CPU, об оперативной памяти, о жестких дисках / SSD?

- `/proc/cpuinfo` — модель и характеристики процессора(ов);
- `/proc/meminfo` — объём и состояние оперативной памяти;
- `/proc/<pid>/maps`, `/proc/<pid>/status` — карта памяти и состояние конкретного процесса;
- `/sys/block/*` — информация о блоковых устройствах (дисках, SSD);
- `/sys/class/net/*` — сетевые интерфейсы.

Все эти пути относятся к виртуальным файловым системам (`proc`, `sysfs`), их содержимое генерируется ядром динамически и
не хранится на диске как обычные файлы.
